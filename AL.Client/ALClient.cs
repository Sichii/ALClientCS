using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using AL.APIClient;
using AL.APIClient.Definitions;
using AL.APIClient.Extensions;
using AL.APIClient.Model;
using AL.Client.Extensions;
using AL.Client.Helpers;
using AL.Client.Managers;
using AL.Client.Model;
using AL.Core.Abstractions;
using AL.Core.Definitions;
using AL.Core.Extensions;
using AL.Core.Helpers;
using AL.Core.Model;
using AL.Data;
using AL.SocketClient;
using AL.SocketClient.Definitions;
using AL.SocketClient.Model;
using AL.SocketClient.SocketModel;
using Chaos.Core.Collections.Synchronized.Awaitable;
using Chaos.Core.Extensions;
using Character = AL.SocketClient.Model.Character;
using Condition = AL.Core.Definitions.Condition;
using CONSTANTS = AL.Client.Definitions.CONSTANTS;

// ReSharper disable PrivateFieldCanBeConvertedToLocalVariable

namespace AL.Client
{
    /// <summary>
    ///     Provides the ability to interact with the Adventure.Land socket server.
    /// </summary>
    /// <seealso cref="NamedLoggerBase" />
    /// <seealso cref="IAsyncDisposable" />
    public class ALClient : NamedLoggerBase, IAsyncDisposable
    {
        private static readonly SemaphoreSlim ConnectSync = new(1, 1);
        private readonly PingManager PingManager;
        private readonly PositionManager PositionManager;
        private readonly SemaphoreSlim Sync = new(1, 1);

        /// <summary>
        ///     This will be populated and persist after the first time this character enters the bank.
        /// </summary>
        public BankInfo? Bank { get; private set; }

        /// <summary>
        ///     A collection of values indicating base gold rewards for killing a monster on a specific map. <br />
        ///     These values are dynamically generated by the server, and different based on class, level, and other factors.
        ///     <br />
        ///     { MonsterName : { MapName: GoldValue } }
        /// </summary>
        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, int>> BaseGold { get; private set; }

        /// <summary>
        ///     This will be populated upon connecting. The character this client is for.
        /// </summary>
        public Character Character { get; private set; }

        /// <summary>
        ///     This will be populated upon connecting. The bosses and events currently active on this <see cref="Server" />.
        /// </summary>
        public EventAndBossInfo EventsAndBosses { get; private set; }

        /// <summary>
        ///     The <see cref="Character" />'s unique identifier, as fetched via the <see cref="API" />.
        /// </summary>
        public string? Identifier { get; private set; }

        /// <summary>
        ///     Contains information about the party.
        /// </summary>
        public PartyUpdateData Party { get; private set; } = new();

        /// <summary>
        ///     The will be populated while connecting. Contains information from the <see cref="API" /> about the server we're
        ///     connecting to.
        /// </summary>
        public Server Server { get; private set; }

        /// <summary>
        ///     Our connection to the Adventure.Land socket server.
        /// </summary>
        public ALSocketClient Socket { get; init; }

        /// <summary>
        ///     The character's progress towards ongoing achievements.
        /// </summary>
        public AwaitableDictionary<string, AchievementProgressData> AchievementProgress { get; }

        /// <summary>
        ///     Our connection to the Adventure.Land API. Also contains information about the currently logged in user.
        /// </summary>
        public ALAPIClient API { get; }

        /// <summary>
        ///     When a chest drops or is opened, it will be populated or removed from this collection.
        /// </summary>
        public AwaitableDictionary<string, DropData> Chests { get; }

        /// <summary>
        ///     When a skill is used and the server sends back a cooldown, it will be populated here.
        /// </summary>
        public AwaitableDictionary<string, CooldownInfo> Cooldowns { get; }

        /// <summary>
        ///     A collection of the monsters we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, Monster> Monsters { get; }

        /// <summary>
        ///     The name of the character this client is for.
        /// </summary>
        public override string Name { get; }

        /// <summary>
        ///     A collection of the players we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, Player> Players { get; }

        /// <summary>
        ///     A collection of projectiles we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, ActionData> Projectiles { get; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ALClient" /> class.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="apiClient"></param>
        /// <exception cref="ArgumentNullException">name</exception>
        /// <exception cref="ArgumentNullException">apiClient</exception>
        public ALClient(string name, ALAPIClient apiClient)
            : base(name)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentNullException(nameof(name));

            Name = name;
            AchievementProgress = new AwaitableDictionary<string, AchievementProgressData>();
            API = apiClient ?? throw new ArgumentNullException(nameof(apiClient));
            Monsters = new AwaitableDictionary<string, Monster>();
            Players = new AwaitableDictionary<string, Player>();
            Projectiles = new AwaitableDictionary<string, ActionData>();
            BaseGold = new Dictionary<string, IReadOnlyDictionary<string, int>>();
            Cooldowns = new AwaitableDictionary<string, CooldownInfo>(StringComparer.OrdinalIgnoreCase);
            EventsAndBosses = new EventAndBossInfo();
            Chests = new AwaitableDictionary<string, DropData>();
            Socket = new ALSocketClient(name);
            Character = null!;
            Server = null!;

            PingManager = new PingManager(this);
            PositionManager = new PositionManager(this);
        }

        /// <summary>
        ///     Determines if you should be able to buy an item.
        /// </summary>
        /// <param name="itemName">The name of the buyable item.</param>
        /// <param name="fromPonty">Whether or not you're trying to buy it from Ponty.</param>
        /// <param name="distanceCheck">Whether or not to include a distance check.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be bought, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanBuy(string itemName, bool fromPonty = false, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (Character.EmptySlots == 0)
                return false;

            var data = GameData.Items[itemName];

            if (data == null)
                return false;

            var price = data.Gold;

            if (fromPonty)
                price *= CONSTANTS.PONTY_MARKUP;

            if (price > Character.Gold)
                return false;

            if (!distanceCheck || Character.Inventory.ContainsItem("computer"))
                return true;

            if (fromPonty)
                return GameData.NPCs["secondhands"]!.Locations.Any(location =>
                    location.Distance(Character) < CONSTANTS.NPC_RANGE);

            if (data.ObtainType != ObtainType.Buy)
                return false;

            return data.ObtainableFromNPC!.Locations.Any(location =>
                Character.Distance(location) < CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to craft an item.
        /// </summary>
        /// <param name="itemName">The name of a craftable item.</param>
        /// <param name="includeBank">
        ///     Whether or not to include banked gold/items in the check. (only works if <see cref="Bank" />
        ///     has been populated)
        /// </param>
        /// <param name="distanceCheck">Whether or not to include a distance check.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be crafted, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <remarks>
        ///     There should never be a reason to use <paramref name="includeBank" /> and <paramref name="distanceCheck" />
        ///     together.
        /// </remarks>
        public bool CanCraft(string itemName, bool includeBank = false, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            var data = GameData.Items[itemName];

            if ((data == null) || (data.ObtainType != ObtainType.Craft) || (data.ObtainableFromNPC == null))
                return false;

            var gold = Character.Gold;

            if (includeBank && (Bank != null))
                gold += Bank.Gold;

            if (data.Recipe!.Cost > gold)
                return false;

            foreach ((var quantity, var name, var level) in data.Recipe!.Items)
                if (Character.Inventory.FindItem(name, level, quantity) == null)
                    if (!includeBank || (Bank == null) || (Bank.FindItem(name, level, quantity) == null))
                        return false;

            return !distanceCheck
                   || Character.Inventory.ContainsItem("computer")
                   || data.ObtainableFromNPC.Locations.Any(location =>
                       location.Distance(Character) < CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to exchange an item.
        /// </summary>
        /// <param name="itemName">The name of the exchangeable item.</param>
        /// <param name="distanceCheck">Whether or not to include a distance chack.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be exchanged, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanExchange(string itemName, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            var data = GameData.Items[itemName];

            if ((data == null) || (data.ExchangeCount == null) || (data.ExchangeAtNPC == null))
                return false;

            if (Character.Inventory.CountOf(itemName) < data.ExchangeCount)
                return false;

            return !distanceCheck
                   || Character.Inventory.ContainsItem("computer")
                   || data.ExchangeAtNPC.Locations.Any(location => location.Distance(Character) < CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to sell an item.
        /// </summary>
        /// <param name="itemName">The name of the sellable item.</param>
        /// <returns><c>true</c> if the item can be sold, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanSell(string itemName)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (!Character.Inventory.ContainsItem(itemName))
                return false;

            if (Character.Inventory.ContainsItem("computer"))
                return true;

            var map = GameData.Maps[Character.Map];

            if (map == null)
                return true;

            foreach (var npc in map.NPCs)
                if ((npc.Data?.Items != null)
                    && npc.Data.Locations.Any(location => location.Distance(Character) < CONSTANTS.NPC_RANGE))
                    return true;

            return false;
        }

        /// <summary>
        ///     Determines if this skill can be used.
        /// </summary>
        /// <param name="skillName">The name of the skill.</param>
        /// <param name="checkWeapon">
        ///     Whether or not to check the equipped weapon against the required weapon type. (if there is
        ///     one)
        /// </param>
        /// <returns><c>true</c> if the skill can be used, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">skillName</exception>
        public async ValueTask<bool> CanUseSkill(string skillName, bool checkWeapon = true)
        {
            if (string.IsNullOrEmpty(skillName))
                throw new ArgumentNullException(nameof(skillName));

            if (Character.RIP
                || await Character.Conditions.ContainsKeyAsync(Condition.Stoned)
                || (skillName.EqualsI("blink") && await Character.Conditions.ContainsKeyAsync(Condition.Dampened))
                || !await IsOffCooldown(skillName))
                return false;

            var data = GameData.Skills[skillName]!;

            if ((data.Classes != null) && !data.Classes.Contains(Character.Class))
                return false;

            if (data.Level.HasValue && (Character.Level < data.Level))
                return false;

            if (data.AttributeRequirements != null)
                foreach ((var attribute, var requiredValue) in data.AttributeRequirements)
                {
                    if (!Character.Attributes.TryGetValue(attribute, out var value))
                        value = 0;

                    if (requiredValue > value)
                        return false;
                }

            bool isAttack;
            if ((isAttack = skillName.EqualsI("attack")) || skillName.EqualsI("heal"))
            {
                if (Character.MP < Character.MPCost)
                    return false;

                var mainHand = Character.Slots[Slot.MainHand];
                var mainHandData = mainHand?.GetData();
                var classData = Character.GetData();

                if ((mainHand == null)
                    || (classData == null)
                    || (mainHandData == null)
                    || (!classData.CanMainHand(mainHandData.WeaponType)
                        && !classData.Can2Hand(mainHandData.WeaponType)))
                    return false;

                if (isAttack && mainHand.Name.EqualsI("dartgun") && (Character.Gold < 100))
                    return false;
            } else if (Character.MP < data.MP)
                return false;

            if (!string.IsNullOrEmpty(data.Consume) && !Character.Inventory.ContainsItem(data.Consume))
                return false;

            if ((data.RequiredInventoryItems != null)
                && !data.RequiredInventoryItems.All(itemName => Character.Inventory.ContainsItem(itemName)))
                return false;

            if (data.RequiredSlotItems != null)
            {
                var equipped = false;
                foreach ((var equipmentSlot, var itemName) in data.RequiredSlotItems)
                {
                    var slotItem = Character.Slots[equipmentSlot.ToSlot()];

                    if ((slotItem != null) && slotItem.Name.EqualsI(itemName))
                    {
                        equipped = true;
                        break;
                    }
                }

                if (!equipped)
                    return false;
            }

            if (checkWeapon && (data.WeaponTypes != null))
            {
                var slotItem = Character.Slots[Slot.MainHand];

                if ((slotItem == null) || !data.WeaponTypes.Contains(slotItem.GetData()?.WeaponType ?? WeaponType.None))
                    return false;
            }

            return true;
        }

        public async ValueTask DisposeAsync()
        {
            GC.SuppressFinalize(this);
            await DisconnectAsync();
        }

        /// <summary>
        ///     Determines if this skill is off cooldown. (shared cooldown if it has one)
        /// </summary>
        /// <param name="skillName">The name of the skill.</param>
        /// <returns><c>true</c> if the skill is off cooldown, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">skillName</exception>
        public async ValueTask<bool> IsOffCooldown(string skillName)
        {
            if (string.IsNullOrEmpty(skillName))
                throw new ArgumentNullException(nameof(skillName));

            var data = GameData.Skills[skillName];

            if (data == null)
                return false;

            if (!string.IsNullOrEmpty(data.SharedCooldown))
                skillName = data.SharedCooldown;

            return !await Cooldowns.TryGetValueAsync(skillName, out var cooldownTask)
                   || !(await cooldownTask).CanUse(PingManager.Offset);
        }

        #region Connection stuff

        /// <summary>
        ///     Asynchronously connects to an Adventure.Land socket server.
        /// </summary>
        /// <param name="region">The region to connect to.</param>
        /// <param name="identifier">The identifier within the region to connect to.</param>
        /// <exception cref="InvalidOperationException">There is already an open socket in use. Try disposing it and reconnecting.</exception>
        public async Task ConnectAsync(ServerRegion region, ServerId identifier)
        {
            if (Socket.Open)
                throw new InvalidOperationException(
                    "There is already an open socket in use. Try disposing it and reconnecting.");

            await FetchCharacterAndServerAsync(region, identifier);

            await Sync.WaitAsync();

            try
            {
                AttachListeners();

                var source = new TaskCompletionSource<Expectation<WelcomeData>>();

                await using var gameErrorCallback = Socket.On<GameErrorData>(ALSocketMessageType.GameError,
                    data => Task.FromResult(source.TrySetResult(data.Message)));

                await using var welcomeCallback = Socket.On<WelcomeData>(ALSocketMessageType.Welcome, async data =>
                {
                    await Socket.Emit(ALSocketEmitType.Auth, new
                    {
                        auth = API.AuthUser.AuthKey,
                        character = Identifier,
                        height = 1080,
                        no_graphics = "True",
                        no_html = "1",
                        passphrase = string.Empty,
                        scale = 2,
                        user = API.AuthUser.UserID.ToString(),
                        width = 1920
                    });

                    return source.TrySetResult(data);
                });

                await Socket.ConnectAsync(Server!);

                var result = await source.Task.WithTimeout(5000);
                result.ThrowIfUnsuccessful();

                PositionManager.Start(30);
                PingManager.Start(1 / 4f);
            } finally
            {
                Sync.Release();
            }
        }

        /// <summary>
        ///     This is just a shorthand for creating an <see cref="ALClient" /> and calling <see cref="ConnectAsync" />.
        /// </summary>
        /// <param name="characterName">The name of the character to log in as.</param>
        /// <param name="region">The region to log into.</param>
        /// <param name="identifier">The identifier suffic for the region.</param>
        /// <param name="apiClient">An <see cref="ALAPIClient" /> with your authorization credentials.</param>
        /// <returns>
        ///     <see cref="ALClient" />
        /// </returns>
        /// <exception cref="ArgumentNullException">characterName</exception>
        /// <exception cref="ArgumentNullException">apiClient</exception>
        public static async Task<ALClient> StartCharacterAsync(
            string characterName,
            ServerRegion region,
            ServerId identifier,
            ALAPIClient apiClient)
        {
            if (string.IsNullOrEmpty(characterName))
                throw new ArgumentNullException(nameof(characterName));

            if (apiClient == null)
                throw new ArgumentNullException(nameof(apiClient));

            var client = new ALClient(characterName, apiClient);
            await client.ConnectAsync(region, identifier);

            return client;
        }

        /// <summary>
        ///     <inheritdoc cref="ALSocketClient.DisconnectAsync" />
        /// </summary>
        public async Task DisconnectAsync()
        {
            await Sync.WaitAsync();

            try
            {
                Warn("Disconnecting");
                await Socket.DisconnectAsync();
            } finally
            {
                Sync.Release();
            }
        }

        private async Task FetchCharacterAndServerAsync(ServerRegion region, ServerId identifier)
        {
            await ConnectSync.WaitAsync();

            try
            {
                //if servers/characters not populated, populate them
                if ((API.Servers == null)
                    || (API.Servers.Count == 0)
                    || (API.Characters == null)
                    || (API.Characters.Count == 0))
                    await API.UpdateServersAndCharactersAsync();
            } finally
            {
                ConnectSync.Release();
            }

            //find server and character
            var charInfo = API.Characters!.FirstOrDefault(character => character.Name.EqualsI(Name));
            var serverInfo =
                API.Servers!.FirstOrDefault(server => (server.Region == region) && (server.Identifier == identifier));

            if (charInfo == null)
                throw new InvalidOperationException($@"Character ""{Name}"" not found.");

            if (serverInfo == null)
                throw new InvalidOperationException($@"Server {region} {identifier} not found.");

            Server = serverInfo;
            Identifier = charInfo.Id;
        }

        #endregion

        #region Actions

        /// <summary>
        ///     Asynchronously accepts a magiport offer.
        /// </summary>
        /// <param name="from">The name of the character who offered the magiport.</param>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     Information about the map you got magiported to.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        public async Task<NewMapData> AcceptMagiportAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<NewMapData>>();

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Magiport, new { name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously accepts a party invite.
        /// </summary>
        /// <param name="from">The name of the character who invited you.</param>
        /// <returns>
        ///     <see cref="PartyUpdateData" /> <br />
        ///     Information about the party state after accepting the invite.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        /// <exception cref="InvalidOperationException">Failed to accept party invite. ({reason})</exception>
        public async Task<PartyUpdateData> AcceptPartyInviteAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<PartyUpdateData>>();

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
            {
                var result = false;

                if (data.MemberNames.ContainsI(from))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("invitation expired") || data.EqualsI($"{from} is not found"))
                    result = source.TrySetResult($"Failed to accept party invite. ({data})");
                else if (data.EqualsI("already partying"))
                    if (Party == null)
                        result = source.TrySetResult($"Failed to accept party invite. ({data})");
                    else
                        result = Party.MemberNames.ContainsI(from)
                            ? source.TrySetResult(Party)
                            : source.TrySetResult($"Failed to accept party invite. ({data})");

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Party, new { @event = "accept", name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously accepts a party request.
        /// </summary>
        /// <param name="from">The name of the character who requested the invite.</param>
        /// <returns>
        ///     <see cref="PartyUpdateData" /> <br />
        ///     Information about the party state after accepting the request.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        /// <exception cref="InvalidOperationException">Failed to accept party request. ({reason})</exception>
        public async Task<PartyUpdateData> AcceptPartyRequestAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<PartyUpdateData>>();

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
            {
                var result = false;

                if (data.MemberNames.ContainsI(from))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("request expired") || data.EqualsI($"Failed to accept party request. ({data})"))
                    result = source.TrySetResult(data);
                else if (data.EqualsI("already partying"))
                    if (Party == null)
                        result = source.TrySetResult($"Failed to accept party request. ({data})");
                    else
                        result = Party.MemberNames.ContainsI(from)
                            ? source.TrySetResult(Party)
                            : source.TrySetResult($"Failed to accept party request. ({data})");

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Party, new { @event = "raccept", name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to attack a target.
        /// </summary>
        /// <param name="targetId">The id of the target to attack.</param>
        /// <returns>
        ///     <see cref="ActionData" /> <br />
        ///     Details about the action taken.
        /// </returns>
        /// <exception cref="ArgumentNullException">targetId</exception>
        /// <exception cref="InvalidOperationException">Attack on {targetId} failed. ({reason})</exception>
        public async Task<ActionData> AttackAsync(string targetId)
        {
            if (string.IsNullOrEmpty(targetId))
                throw new ArgumentNullException(nameof(targetId));

            var source = new TaskCompletionSource<Expectation<ActionData>>();

            await using var deathCallback = Socket.On<DeathData>(ALSocketMessageType.Death,
                data => Task.FromResult(data.Id.EqualsI(targetId)
                                        && source.TrySetResult($"Attack on {targetId} failed. (target died)")));

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.Disabled when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (disabled)"),
                    GameResponseType.AttackFailed when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (attack failed)"),
                    GameResponseType.TooFar when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (too far: {data.Distance})"),
                    GameResponseType.Cooldown when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (on cooldown: {data.CooldownMS}"),
                    GameResponseType.NoMP when data.Place == "attack" => source.TrySetResult(
                        $"Attack on {targetId} failed. (not enough mp)"),
                    _ => false
                };

                return Task.FromResult(result);
            });

            await using var notThereCallback = Socket.On<NotThereData>(ALSocketMessageType.NotThere,
                data => Task.FromResult(data.Source.EqualsI("attack")
                                        && source.TrySetResult($"Attack on {targetId} failed. (invalid target)")));

            await using var actionCallback = Socket.On<ActionData>(ALSocketMessageType.Action, data =>
            {
                var result = false;

                if (data.AttackerId.EqualsI(Character.Id)
                    && data.Target.EqualsI(targetId)
                    && data.Type.EqualsI("attack"))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Attack, new { id = targetId });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from an NPC.
        /// </summary>
        /// <param name="itemName">The name of the item to buy.</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="SimpleItem" /> <br />
        ///     Basic information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <exception cref="InvalidOperationException">Quantity cannot be below 1.</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {itemName}. ({reason})</exception>
        public async Task<IndexedSimpleItem> BuyAsync(string itemName, int quantity = 1)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (quantity < 1)
                throw new InvalidOperationException("Quantity cannot be below 1.");

            var source = new TaskCompletionSource<Expectation<IndexedSimpleItem>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.BuySuccess => source.TrySetResult(new IndexedSimpleItem
                    {
                        Index = data.SlotNum,
                        Item = new SimpleItem
                        {
                            Name = data.Name!,
                            Quantity = data.Quantity
                        }
                    }),
                    GameResponseType.BuyCantNPC => source.TrySetResult($"Failed to buy {itemName}. (wrong npc)"),
                    GameResponseType.BuyCantSpace => source.TrySetResult(
                        $"Failed to buy {itemName}. (not enough space)"),
                    GameResponseType.BuyCost => source.TrySetResult($"Failed to buy {itemName}. (not enough gold)"),
                    GameResponseType.BuyGetCloser => source.TrySetResult(
                        $"Failed to buy {itemName}. (get closer: {data.Distance})"),
                    _ => false
                };

                return Task.FromResult(result);
            });

            if (GameData.Items[itemName]?.StackSize > 1)
                await Socket.Emit(ALSocketEmitType.Buy, new { name = itemName, quantity });
            else
                await Socket.Emit(ALSocketEmitType.Buy, new { name = itemName });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from a player.
        /// </summary>
        /// <param name="playerName">The name of the player to buy from.</param>
        /// <param name="slot">The slot the item is in.</param>
        /// <param name="item">The item to buy</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="IndexedInventoryItem" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">playerName</exception>
        /// <exception cref="ArgumentNullException">item</exception>
        /// <exception cref="InvalidOperationException">{reason}</exception>
        /// <remarks>
        ///     There are cases of wrong information where server will not indicate something went wrong.
        ///     Our solution is to handle those cases ourself.
        /// </remarks>
        public async Task<IndexedInventoryItem> BuyFromPlayerAsync(
            string playerName,
            TradeSlot slot,
            TradeItem item,
            int quantity = 1)
        {
            if (string.IsNullOrEmpty(playerName))
                throw new ArgumentNullException(nameof(playerName));

            if (item == null)
                throw new ArgumentNullException(nameof(item));

            Player player;
            if (!await Players.TryGetValueAsync(playerName, out var playerTask)
                || ((player = await playerTask) == null))
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (seller gone)");

            if (Character.Distance(player) > CONSTANTS.NPC_RANGE)
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (get closer)");

            var slotItem = player.Slots[slot.ToSlot()];
            if ((slotItem == null) || (slotItem.Id != item.Id))
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (wrong id)");

            var source = new TaskCompletionSource<Expectation<IndexedInventoryItem>>();

            var inventorySnapshot = Character.Inventory.AsIndexed();
            var existingTotal = Character.Inventory.CountOf(item.Name);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = false;

                if (data.ResponseType == GameResponseType.TradeGetCloser)
                    result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. (get closer)");

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("not enough gold")
                    || data.EqualsI("you can't buy that many")
                    || data.EqualsI("seller gone"))
                    result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. ({data})");

                return Task.FromResult(result);
            });

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(
                ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. (no space)");

                    return Task.FromResult(result);
                });

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
            {
                var result = false;

                var newTotal = data.Inventory.CountOf(item.Name);

                if (newTotal - existingTotal == quantity)
                    result = source.TrySetResult(data.Inventory.AsIndexed().Except(inventorySnapshot).First());

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.TradeBuy,
                new { slot, id = playerName, rid = item.Id, q = quantity.ToString() });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Attempts to buy an item from Ponty. <br />
        ///     Ponty sells items other players have sold to NPCs, but at a 20% markup.
        /// </summary>
        /// <param name="item">The item to buy.</param>
        /// <returns>
        ///     <see cref="IndexedInventoryItem" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">item</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {item.Name}. ({reason})</exception>
        public async Task<IndexedInventoryItem> BuyFromPontyAsync(TradeItem item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            var source = new TaskCompletionSource<Expectation<IndexedInventoryItem>>();
            var existingCount = Character.Inventory.CountOf(item.Name);
            var existingItems = Character.Inventory.AsIndexed();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = false;

                if (data.ResponseType == GameResponseType.BuyCost)
                    result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. (not enough gold)");

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("item gone"))
                    result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. ({data})");

                return Task.FromResult(result);
            });

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(
                ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. ({data.Message})");

                    return Task.FromResult(result);
                });

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
            {
                var result = false;
                var newCount = data.Inventory.CountOf(item.Name);

                if (newCount - existingCount == item.Quantity)
                    result = source.TrySetResult(data.Inventory.AsIndexed().Except(existingItems).First());

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.SecondHandsBuy, new { rid = item.Id });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Attempts to compound 3 items of the same level/name.
        /// </summary>
        /// <param name="itemIndex1">The inventory index of the first item.</param>
        /// <param name="itemIndex2">The inventory index of the second item.</param>
        /// <param name="itemIndex3">The inventory index of the third item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the compound succeeded, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to compound. ({reason})</exception>
        public async Task<bool> CompoundAsync(
            int itemIndex1,
            int itemIndex2,
            int itemIndex3,
            int scrollIndex,
            int? offeringIndex = null)
        {
            var item = Character.Inventory[itemIndex1];
            var source = new TaskCompletionSource<Expectation<bool?>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.MiscFail when data.Place.EqualsI("compound") => source.TrySetResult(
                        "Failed to compound. (misc, more than 1 issue)"),
                    //this actually occurs when we set "clevel" to the wrong value, but that should only happen if index1 is the wrong item, or no item.
                    GameResponseType.CompoundNoItem => source.TrySetResult("Failed to compound. (items not the same)"),
                    GameResponseType.CompoundInProgress => source.TrySetResult(
                        "Failed to compound. (already compounding)"),
                    GameResponseType.CompoundIncompatibleScroll => source.TrySetResult(
                        "Failed to compound. (wrong scroll)"),
                    GameResponseType.CompoundMismatch => source.TrySetResult(
                        "Failed to compound. (items not the same)"),
                    GameResponseType.CompoundCant => source.TrySetResult(
                        "Failed to compound. (items not compoundable)"),
                    GameResponseType.CompoundInvalidOffering => source.TrySetResult(
                        "Failed to compound. (offering is not an offering)"),
                    GameResponseType.Exception when data.Place.EqualsI("compound") => source.TrySetResult(
                        "Failed to compound. (exception, major issues)"),
                    GameResponseType.BankRestrictions => source.TrySetResult(
                        "Failed to compound. (can't compound from bank)"),
                    GameResponseType.ECUGetCloser    => source.TrySetResult("Failed to compound. (get closer)"),
                    GameResponseType.CompoundSuccess => source.TrySetResult(true),
                    GameResponseType.CompoundFail    => source.TrySetResult(false),
                    _                                => false
                };

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Compound, new
            {
                items = new[] { itemIndex1, itemIndex2, itemIndex3 },
                scroll_num = scrollIndex,
                clevel = item?.Level ?? 0,
                offering_num = offeringIndex
            });

            return await source.Task.WithTimeout(60000);
        }

        /// <summary>
        ///     Attempts to have the server calculate the chance for a compound to succeed.
        /// </summary>
        /// <param name="itemIndex1">The inventory index of the first item.</param>
        /// <param name="itemIndex2">The inventory index of the second item.</param>
        /// <param name="itemIndex3">The inventory index of the third item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="ChanceItem" /> <br />
        ///     An object containing details about the item, and it's chance to successully be compounded.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to compound. ({reason})</exception>
        public async Task<ChanceItem> CompoundCalculateAsync(
            int itemIndex1,
            int itemIndex2,
            int itemIndex3,
            int scrollIndex,
            int? offeringIndex = null)
        {
            var item = Character.Inventory[itemIndex1];
            var source = new TaskCompletionSource<Expectation<ChanceItem>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.MiscFail when data.Place.EqualsI("compound") => source.TrySetResult(
                        "Failed to compound. (misc, more than 1 issue)"),
                    //this actually occurs when we set "clevel" to the wrong value, but that should only happen if index1 is the wrong item, or no item.
                    GameResponseType.CompoundNoItem => source.TrySetResult("Failed to compound. (items not the same)"),
                    GameResponseType.CompoundInProgress => source.TrySetResult(
                        "Failed to compound. (already compounding)"),
                    GameResponseType.CompoundIncompatibleScroll => source.TrySetResult(
                        "Failed to compound. (wrong scroll)"),
                    GameResponseType.CompoundMismatch => source.TrySetResult(
                        "Failed to compound. (items not the same)"),
                    GameResponseType.CompoundCant => source.TrySetResult(
                        "Failed to compound. (items not compoundable)"),
                    GameResponseType.CompoundInvalidOffering => source.TrySetResult(
                        "Failed to compound. (offering is not an offering)"),
                    GameResponseType.Exception when data.Place.EqualsI("compound") => source.TrySetResult(
                        "Failed to compound. (exception, major issues)"),
                    GameResponseType.BankRestrictions => source.TrySetResult(
                        "Failed to compound. (can't compound from bank)"),
                    GameResponseType.ECUGetCloser => source.TrySetResult("Failed to compound. (get closer)"),
                    GameResponseType.CompoundChance when data.Item?.Name.EqualsI(item?.Name) ?? false =>
                        source.TrySetResult(data.Item with { Grace = data.Grace, Chance = data.Chance }),
                    _ => false
                };

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Compound, new
            {
                items = new[] { itemIndex1, itemIndex2, itemIndex3 },
                scroll_num = scrollIndex,
                clevel = item?.Level ?? 0,
                offering_num = offeringIndex,
                calculate = 1
            });

            return await source.Task.WithTimeout(60000);
        }

        /// <summary>
        ///     Attempts to exchange an item.
        /// </summary>
        /// <param name="itemIndex">The index of the item to exchange.</param>
        /// <returns>
        ///     <see cref="IndexedInventoryItem" /> <br />
        ///     The item received from the exchange.
        /// </returns>
        /// <exception cref="InvalidOperationException"></exception>
        /// <remarks>
        ///     There are cases of wrong information where server will not indicate something went wrong.
        ///     Our solution is to handle those cases ourself.
        /// </remarks>
        public async Task<IndexedInventoryItem> ExchangeAsync(int itemIndex)
        {
            if (itemIndex >= Character.InventorySize)
                throw new InvalidOperationException("Failed to exchange. (index out of range)");

            var item = Character.Inventory[itemIndex];

            if (item == null)
                throw new InvalidOperationException("Failed to exchange. (no item at index)");

            var itemData = item.GetData();

            if (itemData == null)
                throw new InvalidOperationException("Failed to exchange. (no data, contact me)");

            if ((itemData.ExchangeAtNPC == null) || !itemData.ExchangeCount.HasValue)
                throw new InvalidOperationException("Failed to exchange. (item not exchangeable)");

            if (itemData.ExchangeCount > item.Quantity)
                throw new InvalidOperationException($"Failed to exchange. (you do not have {itemData.ExchangeCount})");

            var source = new TaskCompletionSource<Expectation<IndexedInventoryItem>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.ExchangeNotEnough => source.TrySetResult(
                        $"Failed to exchange. (youd to not have {itemData.ExchangeCount})"),
                    GameResponseType.ECUGetCloser => source.TrySetResult("Failed to exchange. (get closer)"),
                    GameResponseType.BankRestrictions => source.TrySetResult(
                        "Failed to exchange. (can't exchange from bank)"),
                    _ => false
                };

                return Task.FromResult(result);
            });

            var exchangeStarted = false;
            Inventory? itemsSnapshot = null;
            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
            {
                var result = false;

                if (!exchangeStarted
                    && (data.QueuedActions?.Exchange != null)
                    && (data.QueuedActions.Exchange.CurrentMS == data.QueuedActions.Exchange.LengthMS))
                    exchangeStarted = true;

                if (exchangeStarted)
                {
                    if (data.QueuedActions?.Exchange == null)
                        result = source.TrySetResult(Character.Inventory.AsIndexed()
                            .Except(itemsSnapshot!.AsIndexed())
                            .First());
                    else
                        itemsSnapshot = Character.Inventory;
                }

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Exchange, new
            {
                item_num = itemIndex,
                q = itemData.ExchangeCount
            });

            return await source.Task.WithTimeout(60000);
        }

        /// <summary>
        ///     Asynchronously pings the server.
        /// </summary>
        /// <param name="pingCount">The current ping count.</param>
        /// <returns>
        ///     <see cref="PingAckData" /> <br />
        ///     The ping acknowledgement from the server.
        /// </returns>
        public async Task<PingAckData> PingAsync(long pingCount)
        {
            var source = new TaskCompletionSource<Expectation<PingAckData>>();

            await using var pingAckCallback = Socket.On<PingAckData>(ALSocketMessageType.PingAck,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Ping, new { id = pingCount.ToString() });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously requests your character's data from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="CharacterData" /> <br />
        ///     The character's data.
        /// </returns>
        public async Task<CharacterData> RequestCharacterAsync()
        {
            var source = new TaskCompletionSource<Expectation<CharacterData>>();

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Property, new { typing = true });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously requests a full entity refresh from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="EntitiesData" /> <br />
        ///     A full refresh of entity data.
        /// </returns>
        public async Task<EntitiesData> RequestEntitiesAsync()
        {
            var source = new TaskCompletionSource<Expectation<EntitiesData>>();

            await using var entitiesCallback = Socket.On<EntitiesData>(ALSocketMessageType.Entities,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.SendUpdates, new object());
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Attempts to upgrade an item.
        /// </summary>
        /// <param name="itemIndex">The inventory index of the item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the upgrade succeeded, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to upgrade. ({reason})</exception>
        public async Task<bool> UpgradeAsync(int itemIndex, int scrollIndex, int? offeringIndex = null)
        {
            var item = Character.Inventory[itemIndex];
            var source = new TaskCompletionSource<Expectation<bool?>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.UpgradeNoItem => source.TrySetResult("Failed to compound. (items not the same)"),
                    GameResponseType.UpgradeInProgress => source.TrySetResult("Failed to upgrade. (already upgrading)"),
                    GameResponseType.UpgradeIncompatibleScroll => source.TrySetResult(
                        "Failed to upgrade. (wrong scroll)"),
                    GameResponseType.UpgradeNoScroll => source.TrySetResult("Failed to upgrade. (no scroll)"),
                    GameResponseType.UpgradeMismatch => source.TrySetResult(
                        "Failed to upgrade. (unknown, this seems to be a catch-all)"),
                    GameResponseType.UpgradeCant => source.TrySetResult("Failed to upgrade. (item not upgradable)"),
                    GameResponseType.UpgradeInvalidOffering => source.TrySetResult(
                        "Failed to upgrade. (offering is not an offering)"),
                    GameResponseType.BankRestrictions => source.TrySetResult(
                        "Failed to upgrade. (can't upgrade from bank)"),
                    GameResponseType.ECUGetCloser   => source.TrySetResult("Failed to upgrade. (get closer)"),
                    GameResponseType.UpgradeSuccess => source.TrySetResult(true),
                    GameResponseType.UpgradeFail    => source.TrySetResult(false),
                    _                               => false
                };

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Upgrade, new
            {
                item_num = itemIndex, scroll_num = scrollIndex, offering_num = offeringIndex,
                clevel = item?.Level ?? 0
            });

            return await source.Task.WithTimeout(60000);
        }

        /// <summary>
        ///     Attempts to have the server calculate the chance for an upgrade to succeed.
        /// </summary>
        /// <param name="itemIndex">The inventory index of the item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="ChanceItem" /> <br />
        ///     An object containing details about the item, and it's chance to successully be upgraded.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to upgrade. ({reason})</exception>
        public async Task<ChanceItem> UpgradeChanceAsync(int itemIndex, int scrollIndex, int? offeringIndex = null)
        {
            var item = Character.Inventory[itemIndex];
            var source = new TaskCompletionSource<Expectation<ChanceItem>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.UpgradeNoItem     => source.TrySetResult("Failed to compound. (no item at index)"),
                    GameResponseType.UpgradeInProgress => source.TrySetResult("Failed to upgrade. (already upgrading)"),
                    GameResponseType.UpgradeIncompatibleScroll => source.TrySetResult(
                        "Failed to upgrade. (wrong scroll)"),
                    GameResponseType.UpgradeNoScroll => source.TrySetResult("Failed to upgrade. (no scroll)"),
                    GameResponseType.UpgradeMismatch => source.TrySetResult(
                        "Failed to upgrade. (unknown, this seems to be a catch-all)"),
                    GameResponseType.UpgradeCant => source.TrySetResult("Failed to upgrade. (item not upgradable)"),
                    GameResponseType.UpgradeInvalidOffering => source.TrySetResult(
                        "Failed to upgrade. (offering is not an offering)"),
                    GameResponseType.BankRestrictions => source.TrySetResult(
                        "Failed to upgrade. (can't upgrade from bank)"),
                    GameResponseType.ECUGetCloser => source.TrySetResult("Failed to upgrade. (get closer)"),
                    GameResponseType.UpgradeChance when data.Item?.Name.EqualsI(item?.Name) ?? false =>
                        source.TrySetResult(data.Item with { Grace = data.Grace, Chance = data.Chance }),
                    _ => false
                };

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Upgrade, new
            {
                item_num = itemIndex, scroll_num = scrollIndex, offering_num = offeringIndex,
                clevel = item?.Level ?? 0
            });

            return await source.Task.WithTimeout(60000);
        }

        #endregion

        #region Events

        protected void AttachListeners()
        {
            if (Socket == null)
                throw new NullReferenceException(nameof(Socket));

            Socket.On<StartData>(ALSocketMessageType.Start, OnStartAsync);
            Socket.On<CharacterData>(ALSocketMessageType.Character, OnCharacterAsync);
            Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, OnGameResponseAsync);
            Socket.On<EntitiesData>(ALSocketMessageType.Entities, OnEntitiesAsync);
            Socket.On<AchievementProgressData>(ALSocketMessageType.AchievementProgress, OnAchievementProgressAsync);
            Socket.On<DropData>(ALSocketMessageType.Drop, OnDropAsync);
            Socket.On<EvalData>(ALSocketMessageType.Eval, OnEvalAsync);
            Socket.On<GameErrorData>(ALSocketMessageType.GameError, OnGameErrorAsync);
            Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, OnPartyUpdateAsync);
            Socket.On<QueuedActionData>(ALSocketMessageType.QueuedActionData, OnQueuedActionAsync);
            Socket.On<QueuedActionResultData>(ALSocketMessageType.QueuedActionResult, OnQueuedActionResult);
            Socket.On<WelcomeData>(ALSocketMessageType.Welcome, OnWelcomeAsync);
            Socket.On<ActionData>(ALSocketMessageType.Action, OnActionAsync);
            Socket.On<DeathData>(ALSocketMessageType.Death, OnDeathAsync);
            Socket.On<DisappearData>(ALSocketMessageType.Disappear, OnDisappearAsync);
            Socket.On<HitData>(ALSocketMessageType.Hit, OnHitAsync);
            Socket.On<NewMapData>(ALSocketMessageType.NewMap, OnNewMapAsync);
            Socket.On<EventAndBossData>(ALSocketMessageType.ServerInfo, OnServerInfo);
        }

        protected async Task<bool> OnAchievementProgressAsync(AchievementProgressData data)
        {
            await AchievementProgress.AddOrUpdateAsync(data.Name, data);
            return false;
        }

        protected async Task<bool> OnActionAsync(ActionData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId))
                await Projectiles.AddOrUpdateAsync(data.ProjectileId, data);

            return false;
        }

        protected async Task<bool> OnCharacterAsync(CharacterData data)
        {
            Character = data;

            //keep a copy of the bank data
            if (data.Bank != null)
                Bank = data.Bank;

            if (data.ExtraEvents.Count > 0)
                foreach (var jArr in data.ExtraEvents)
                {
                    var raw = jArr.ToString();
                    await Socket!.HandleEventAsync(raw);
                }

            return false;
        }

        protected async Task<bool> OnDeathAsync(DeathData data)
        {
            await DestroyEntity(data.Id);
            return false;
        }

        protected async Task<bool> OnDisappearAsync(DisappearData data)
        {
            await DestroyEntity(data.Id);
            return false;
        }

        protected async Task<bool> OnDropAsync(DropData data)
        {
            await Chests.AddOrUpdateAsync(data.Id, data);
            return false;
        }

        protected async Task<bool> OnEntitiesAsync(EntitiesData data)
        {
            await UpdateMonsters(data.Monsters, data.UpdateType == EntitiesUpdateType.All);
            await UpdatePlayers(data.Players, data.UpdateType == EntitiesUpdateType.All);

            return false;
        }

        //TODO: figure out how to handle eval
        protected Task<bool> OnEvalAsync(EvalData data) => Task.FromResult(false);

        protected Task<bool> OnGameErrorAsync(GameErrorData data)
        {
            Warn($"GAME ERROR: {data.Message}");
            return Task.FromResult(false);
        }

        protected async Task<bool> OnGameResponseAsync(GameResponseData data)
        {
            if (!data.ContainsData)
                return false;

            // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
            switch (data.ResponseType)
            {
                case GameResponseType.Cooldown:
                {
                    await Cooldowns.AddOrUpdateAsync(data.SkillName!, new CooldownInfo(data.CooldownMS));
                    break;
                }
                case GameResponseType.ConditionExpired:
                {
                    if (EnumHelper.TryParse(data.Name, out Condition conditionName))
                        await Character!.Conditions.RemoveAsync(conditionName);

                    break;
                }

                case GameResponseType.SkillSuccess:
                {
                    var skillData = GameData.Skills[data.Name!];
                    var cooldownMS = 0;

                    if ((skillData != null) && (skillData.CooldownMS != 0))
                        cooldownMS = skillData.CooldownMS;

                    await Cooldowns.AddOrUpdateAsync(data.Name!, new CooldownInfo(cooldownMS));
                    break;
                }
            }

            return false;
        }

        protected async Task<bool> OnHitAsync(HitData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId)
                && await Projectiles.TryGetValueAsync(data.ProjectileId, out var projectileTask))
            {
                var projectile = await projectileTask;
                await Projectiles.RemoveAsync(data.ProjectileId);

                if ((data.Reflect != 0) && !string.IsNullOrEmpty(projectile?.ProjectileId))
                {
                    var newProjectile = projectile with
                    {
                        Damage = data.Reflect, Target = data.HitId, X = Character!.X, Y = Character.Y
                    };

                    await Projectiles.AddOrUpdateAsync(newProjectile.ProjectileId, newProjectile);
                }
            }

            if (data.Kill)
                await DestroyEntity(data.Id);
            else if (data.Damage != 0)
            {
                var entity = await GetEntity(data.Id);

                if (entity != null)
                    entity.Mutate(new Mutation(ALAttribute.Hp, -data.Damage));
            }

            if (data.Reflect != 0)
            {
                var sourceEntity = await GetEntity(data.Source);

                if (sourceEntity != null)
                    sourceEntity.Mutate(new Mutation(ALAttribute.Hp, -data.Reflect));
            }

            return false;
        }

        protected async Task<bool> OnNewMapAsync(NewMapData data)
        {
            await Projectiles.ClearAsync();
            Character!.Mutate(data);

            await OnEntitiesAsync(data.Entities);

            return false;
        }

        protected Task<bool> OnPartyUpdateAsync(PartyUpdateData data)
        {
            Party = data;
            return Task.FromResult(false);
        }

        protected Task<bool> OnQueuedActionAsync(QueuedActionData data)
        {
            if (data.QueuedActionInfo != null)
                Character!.Mutate(data.QueuedActionInfo);

            return Task.FromResult(false);
        }

        protected Task<bool> OnServerInfo(EventAndBossData data)
        {
            var bossInfoDic = (Dictionary<string, BossInfo>) data.BossInfo;
            EventsAndBosses = data;

            foreach ((var name, var bossInfo) in bossInfoDic)
                if (bossInfo.HP == 0)
                {
                    var mData = GameData.Monsters[name];

                    if (mData == null)
                        continue;

                    bossInfo.Mutate(new Mutation(ALAttribute.Hp, mData.HP));
                }

            return Task.FromResult(false);
        }

        protected async Task<bool> OnStartAsync(StartData data)
        {
            Character = data;
            BaseGold = data.BaseGold;
            EventsAndBosses = data.EventAndBossInfo;

            await OnEntitiesAsync(data.Entities);
            await OnCharacterAsync(data);

            return false;
        }

        protected Task<bool> OnQueuedActionResult(QueuedActionResultData data)
        {
            if (Character.QueuedActions != null)
                // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                switch (data.QueuedActionType)
                {
                    case QueuedActionType.Compound:
                        Character.Mutate(Character.QueuedActions with { Compound = null });
                        break;
                    case QueuedActionType.Upgrade:
                        Character.Mutate(Character.QueuedActions with { Upgrade = null });
                        break;
                    case QueuedActionType.Exchange:
                        Character.Mutate(Character.QueuedActions with { Exchange = null });
                        break;
                    default:
                        throw new ArgumentOutOfRangeException($"Unknown upgrade type {(int) data.QueuedActionType}.");
                }

            return Task.FromResult(false);
        }

        protected async Task<bool> OnWelcomeAsync(WelcomeData data)
        {
            if ((Server!.Identifier != data.Identifier) || (Server.Region != data.Region))
                throw new Exception(
                    $"Logged into wrong server. Expected: {Server.Region} {Server.Identifier}  Current: {data.Region} {data.Identifier}");

            await Socket!.Emit(ALSocketEmitType.Loaded, new
            {
                height = 1080,
                width = 1920,
                scale = 2,
                success = 1
            });

            return false;
        }

        #endregion

        #region Helpers

        protected async ValueTask<bool> DestroyEntity(string id)
        {
            var result = await Monsters.RemoveAsync(id) || await Players.RemoveAsync(id);

            var bossInfoDic = (Dictionary<string, BossInfo>) EventsAndBosses.BossInfo;
            bossInfoDic.Remove(id);

            return result;
        }

        protected async ValueTask<EntityBase?> GetEntity(string id) =>
            await Players.TryGetValueAsync(id, out var playerTask)   ? await playerTask :
            await Monsters.TryGetValueAsync(id, out var monsterTask) ? await monsterTask : null;

        protected ValueTask UpdateMonsters(IEnumerable<Monster> monsters, bool full = false)
        {
            if (full)
                return Monsters.AssertAsync(dic =>
                {
                    dic.Clear();

                    foreach (var monster in monsters)
                        dic.Add(monster.Id, monster);
                });

            return Monsters.AssertAsync(dic =>
            {
                foreach (var monster in monsters)
                    if (dic.TryGetValue(monster.Id, out var monsterX))
                        monsterX.Mutate(monster);
            });
        }

        protected ValueTask UpdatePlayers(IEnumerable<Player> players, bool full = false)
        {
            if (full)
                return Players.AssertAsync(dic =>
                {
                    dic.Clear();

                    foreach (var player in players)
                        dic.Add(player.Id, player);
                });

            return Players.AssertAsync(dic =>
            {
                foreach (var player in players)
                {
                    if (Character == player)
                        Character.Mutate(player);

                    if (dic.TryGetValue(player.Id, out var playerX))
                        playerX.Mutate(player);
                }
            });
        }

        #endregion
    }
}