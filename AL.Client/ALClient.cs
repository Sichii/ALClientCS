using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using AL.APIClient;
using AL.APIClient.Definitions;
using AL.APIClient.Extensions;
using AL.APIClient.Interfaces;
using AL.APIClient.Model;
using AL.Client.Definitions;
using AL.Client.Extensions;
using AL.Client.Helpers;
using AL.Client.Interfaces;
using AL.Client.Managers;
using AL.Client.Model;
using AL.Core.Definitions;
using AL.Core.Extensions;
using AL.Core.Geometry;
using AL.Core.Helpers;
using AL.Core.Interfaces;
using AL.Core.Model;
using AL.Data;
using AL.Pathfinding;
using AL.Pathfinding.Definitions;
using AL.Pathfinding.Interfaces;
using AL.SocketClient;
using AL.SocketClient.Definitions;
using AL.SocketClient.Interfaces;
using AL.SocketClient.Model;
using AL.SocketClient.SocketModel;
using Chaos.Core.Collections.Synchronized.Awaitable;
using Chaos.Core.Extensions;
using Chaos.Core.Utilities;
using Common.Logging;
using Condition = AL.Core.Definitions.Condition;
using CONSTANTS = AL.Client.Definitions.CONSTANTS;
using CORE_CONSTANTS = AL.Core.Definitions.CONSTANTS;
using PATHFINDING_CONSTANTS = AL.Pathfinding.Definitions.CONSTANTS;

// ReSharper disable PrivateFieldCanBeConvertedToLocalVariable

namespace AL.Client
{
    /// <summary>
    ///     Provides the ability to interact with the Adventure.Land socket server.
    /// </summary>
    /// <seealso cref="IAsyncDisposable" />
    public abstract class ALClient : IAsyncDisposable
    {
        private readonly PingManager PingManager;
        private readonly PositionManager PositionManager;
        private readonly SemaphoreSlim Sync = new(1, 1);

        /// <summary>
        ///     This will be populated and persist after the first time this character enters the bank.
        /// </summary>
        public BankInfo? Bank { get; private set; }

        /// <summary>
        ///     A collection of values indicating base gold rewards for killing a monster on a specific map. <br />
        ///     These values are dynamically generated by the server.
        ///     <br />
        ///     { MonsterName : { MapAccessor: GoldValue } }
        /// </summary>
        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, int>> BaseGold { get; private set; }

        /// <summary>
        ///     This will be populated upon connecting. The bosses and events currently active on this <see cref="Server" />.
        /// </summary>
        public EventAndBossInfo EventsAndBosses { get; private set; }

        /// <summary>
        ///     The <see cref="Character" />'s unique identifier, as fetched via the <see cref="API" />.
        /// </summary>
        public string? Identifier { get; private set; }

        /// <summary>
        ///     Contains information about the party.
        /// </summary>
        public PartyUpdateData Party { get; private set; } = new();

        /// <summary>
        ///     The will be populated while connecting. Contains information from the <see cref="API" /> about the server we're
        ///     connecting to.
        /// </summary>
        public Server Server { get; private set; }

        /// <summary>
        ///     The connection to the Adventure.Land socket server.
        /// </summary>
        public IALSocketClient Socket { get; private set; }

        /// <summary>
        ///     An event fired when a party invite is received.
        /// </summary>
        // ReSharper disable once EventNeverSubscribedTo.Global
        public event EventHandler<InviteData>? OnPartyInvite;

        /// <summary>
        ///     The character's progress towards ongoing achievements. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, AchievementProgressData> AchievementProgress { get; }

        /// <summary>
        ///     The connection to the Adventure.Land API. Also contains information about the currently logged in user.
        /// </summary>
        public IALAPIClient API { get; }

        /// <summary>
        ///     This will be populated upon connecting. The character this client is for.
        /// </summary>
        public Character Character { get; }

        /// <summary>
        ///     When a chest drops or is opened, it will be populated or removed from this collection. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, DropData> Chests { get; }

        /// <summary>
        ///     When a skill is used and the server sends back a cooldown, it will be populated here. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, CooldownInfo> Cooldowns { get; }

        /// <summary>
        ///     A Common.Logging wrapper for this client.
        /// </summary>
        public FormattedLogger Logger { get; }

        /// <summary>
        ///     A collection of the monsters being kept track of. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, Monster> Monsters { get; }

        /// <summary>
        ///     The name of the character this client is for.
        /// </summary>
        public string Name { get; }

        /// <summary>
        ///     A collection of the players being kept track of. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, Player> Players { get; }

        /// <summary>
        ///     A collection of projectiles being kept track of. <br />
        ///     <b>THIS COLLECTION IS SYNCHRONIZED, DO NOT DO LONG RUNNING OPERATIONS WHILE ITERATING IT.</b>
        /// </summary>
        public AwaitableDictionary<string, ActionData> Projectiles { get; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ALClient" /> class.
        /// </summary>
        /// <param name="characterName">The name of the character.</param>
        /// <param name="apiClient">An API client implementation.</param>
        /// <param name="socketClient">A socket client implementation.</param>
        /// <exception cref="ArgumentNullException">name</exception>
        /// <exception cref="ArgumentNullException">apiClient</exception>
        /// <exception cref="ArgumentNullException">socketClient</exception>
        protected ALClient(string characterName, IALAPIClient apiClient, IALSocketClient socketClient)
        {
            if (string.IsNullOrEmpty(characterName))
                throw new ArgumentNullException(nameof(characterName));

            Name = characterName;
            Logger = new FormattedLogger(characterName, LogManager.GetLogger<ALClient>());
            AchievementProgress = new AwaitableDictionary<string, AchievementProgressData>();
            API = apiClient ?? throw new ArgumentNullException(nameof(apiClient));
            Monsters = new AwaitableDictionary<string, Monster>();
            Players = new AwaitableDictionary<string, Player>();
            Projectiles = new AwaitableDictionary<string, ActionData>();
            BaseGold = new Dictionary<string, IReadOnlyDictionary<string, int>>();
            Cooldowns = new AwaitableDictionary<string, CooldownInfo>(StringComparer.OrdinalIgnoreCase);
            EventsAndBosses = new EventAndBossInfo();
            Chests = new AwaitableDictionary<string, DropData>();
            Socket = socketClient ?? throw new ArgumentNullException(nameof(socketClient));
            Server = null!;

            Character = new Character();
            Character.SetBoundingBase(PATHFINDING_CONSTANTS.DEFAULT_BOUNDING_BASE);

            PingManager = new PingManager(this);
            PositionManager = new PositionManager(this);
        }

        public async ValueTask DisposeAsync() => await DisconnectAsync().ConfigureAwait(false);

        #region Checks
        /// <summary>
        ///     Determines if you should be able to buy an item.
        /// </summary>
        /// <param name="itemName">The name of the buyable item.</param>
        /// <param name="fromPonty">Whether or not you're trying to buy it from Ponty.</param>
        /// <param name="distanceCheck">Whether or not to include a distance check.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be bought, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanBuy(string itemName, bool fromPonty = false, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (Character.EmptySlots == 0)
                return false;

            var data = GameData.Items[itemName];

            if (data == null)
                return false;

            var price = data.Gold;

            if (fromPonty)
                price *= CONSTANTS.PONTY_MARKUP;

            if (price > Character.Gold)
                return false;

            if (!distanceCheck || Character.Inventory.ContainsItem("computer"))
                return true;

            if (fromPonty)
                return GameData.NPCs["secondhands"]!.Locations.Any(location =>
                    location.DistanceWithMapCheck(Character) < CORE_CONSTANTS.NPC_RANGE);

            // ReSharper disable once ConvertIfStatementToReturnStatement
            if (data.ObtainType != ObtainType.Buy)
                return false;

            return data.ObtainableFromNPC!.Locations.Any(location => Character.DistanceWithMapCheck(location) < CORE_CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to craft an item.
        /// </summary>
        /// <param name="itemName">The name of a craftable item.</param>
        /// <param name="includeBank">
        ///     Whether or not to include banked gold/items in the check. (only works if <see cref="Bank" />
        ///     has been populated)
        /// </param>
        /// <param name="distanceCheck">Whether or not to include a distance check.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be crafted, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <remarks>
        ///     There should never be a reason to use <paramref name="includeBank" /> and <paramref name="distanceCheck" />
        ///     together.
        /// </remarks>
        public bool CanCraft(string itemName, bool includeBank = false, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            var data = GameData.Items[itemName];

            if ((data?.ObtainType != ObtainType.Craft) || (data.ObtainableFromNPC == null))
                return false;

            var gold = Character.Gold;

            if (includeBank && (Bank != null))
                gold += Bank.Gold;

            if (data.Recipe!.Cost > gold)
                return false;

            foreach ((var quantity, var name, var level) in data.Recipe!.Items)
                if (Character.Inventory.FindItem(name, level, quantity) == null)
                    if (!includeBank || (Bank?.FindItem(name, level, quantity) == null))
                        return false;

            return !distanceCheck
                   || Character.Inventory.ContainsItem("computer")
                   || data.ObtainableFromNPC.Locations.Any(location => location.DistanceWithMapCheck(Character) < CORE_CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to exchange an item.
        /// </summary>
        /// <param name="itemName">The name of the exchangeable item.</param>
        /// <param name="distanceCheck">Whether or not to include a distance chack.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the item can be exchanged, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanExchange(string itemName, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            var data = GameData.Items[itemName];

            if ((data?.ExchangeCount == null) || (data.ExchangeAtNPC == null))
                return false;

            if (Character.Inventory.CountOf(itemName) < data.ExchangeCount)
                return false;

            return !distanceCheck
                   || Character.Inventory.ContainsItem("computer")
                   || data.ExchangeAtNPC.Locations.Any(location => location.DistanceWithMapCheck(Character) < CORE_CONSTANTS.NPC_RANGE);
        }

        /// <summary>
        ///     Determines if you should be able to sell an item.
        /// </summary>
        /// <param name="itemName">The name of the sellable item.</param>
        /// <param name="distanceCheck">Whether or not to include a distance check.</param>
        /// <returns><c>true</c> if the item can be sold, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanSell(string itemName, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (!Character.Inventory.ContainsItem(itemName))
                return false;

            if (!distanceCheck || Character.Inventory.ContainsItem("computer"))
                return true;

            var map = GameData.Maps[Character.Map];

            if (map == null)
                return true;

            foreach (var npc in map.NPCs)
                if ((npc.Data?.Items != null)
                    && npc.Data.Locations.Any(location => location.DistanceWithMapCheck(Character) < CORE_CONSTANTS.NPC_RANGE))
                    return true;

            return false;
        }

        /// <summary>
        ///     Determines if this skill can be used.
        /// </summary>
        /// <param name="skillName">The name of the skill.</param>
        /// <param name="checkWeapon">
        ///     Whether or not to check the equipped weapon against the required weapon type. (if there is
        ///     one)
        /// </param>
        /// <returns><c>true</c> if the skill can be used, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">skillName</exception>
        public async ValueTask<bool> CanUseSkill(string skillName, bool checkWeapon = true)
        {
            if (string.IsNullOrEmpty(skillName))
                throw new ArgumentNullException(nameof(skillName));

            if (Character.RIP
                || await Character.Conditions.ContainsKeyAsync(Condition.Stoned).ConfigureAwait(false)
                || (skillName.EqualsI("blink") && await Character.Conditions.ContainsKeyAsync(Condition.Dampened).ConfigureAwait(false))
                || !await IsOffCooldown(skillName).ConfigureAwait(false))
                return false;

            var data = GameData.Skills[skillName]!;

            if ((data.Classes != null) && !data.Classes.Contains(Character.Class))
                return false;

            if (data.Level.HasValue && (Character.Level < data.Level))
                return false;

            if (data.AttributeRequirements != null)
                foreach ((var attribute, var requiredValue) in data.AttributeRequirements)
                {
                    if (!Character.Attributes.TryGetValue(attribute, out var value))
                        value = 0;

                    if (requiredValue > value)
                        return false;
                }

            bool isAttack;

            if ((isAttack = skillName.EqualsI("attack")) || skillName.EqualsI("heal"))
            {
                if (Character.MP < Character.MPCost)
                    return false;

                var mainHand = Character.Slots[Slot.MainHand];
                var mainHandData = mainHand?.GetData();
                var classData = Character.GetData();

                if ((mainHand == null)
                    || (classData == null)
                    || (mainHandData == null)
                    || (!classData.CanMainHand(mainHandData.WeaponType) && !classData.Can2Hand(mainHandData.WeaponType)))
                    return false;

                if (isAttack && mainHand.Name.EqualsI("dartgun") && (Character.Gold < 100))
                    return false;
            } else if (Character.MP < data.MP)
                return false;

            if (!string.IsNullOrEmpty(data.Consume) && !Character.Inventory.ContainsItem(data.Consume))
                return false;

            if ((data.RequiredInventoryItems != null)
                && !data.RequiredInventoryItems.All(itemName => Character.Inventory.ContainsItem(itemName)))
                return false;

            if (data.RequiredSlotItems != null)
            {
                var equipped = false;

                foreach ((var equipmentSlot, var itemName) in data.RequiredSlotItems)
                {
                    var slotItem = Character.Slots[equipmentSlot.ToSlot()];

                    if ((slotItem != null) && slotItem.Name.EqualsI(itemName))
                    {
                        equipped = true;

                        break;
                    }
                }

                if (!equipped)
                    return false;
            }

            if (checkWeapon && (data.WeaponTypes != null))
            {
                var slotItem = Character.Slots[Slot.MainHand];

                if ((slotItem == null) || !data.WeaponTypes.Contains(slotItem.GetData()?.WeaponType ?? WeaponType.None))
                    return false;
            }

            return true;
        }

        /// <summary>
        ///     Determines if this skill is off cooldown. (shared cooldown if it has one)
        /// </summary>
        /// <param name="skillName">The name of the skill.</param>
        /// <returns><c>true</c> if the skill is off cooldown, otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">skillName</exception>
        public async ValueTask<bool> IsOffCooldown(string skillName)
        {
            if (string.IsNullOrEmpty(skillName))
                throw new ArgumentNullException(nameof(skillName));

            var data = GameData.Skills[skillName];

            if (data == null)
                return false;

            if (!string.IsNullOrEmpty(data.SharedCooldown))
                skillName = data.SharedCooldown;

            return !await Cooldowns.TryGetValueAsync(skillName, out var cooldownTask).ConfigureAwait(false)
                   || (await cooldownTask.ConfigureAwait(false)).CanUse();
        }

        /// <summary>
        ///     Checks if a target is within range of a skill.
        /// </summary>
        /// <param name="target">A target able to have edge-to-edge distance calculated.</param>
        /// <param name="skillName">The name of the skill.</param>
        /// <param name="distanceType">The type of distance to calculate.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the target is within range of the skill, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">skillName</exception>
        /// <exception cref="ArgumentNullException">target</exception>
        public bool WithinSkillRange(IRectangle target, string skillName, DistanceType distanceType = DistanceType.CenterToCenter)
        {
            if (string.IsNullOrEmpty(skillName))
                throw new ArgumentNullException(nameof(skillName));

            if (target == null)
                throw new ArgumentNullException(nameof(target));

            var data = GameData.Skills[skillName];

            if (data == null)
                return false;

            if (data.AffectsParty)
                return true;

            var range = data.Range;

            if (range == 0)
                range = Character.Range;

            if (data.RangeMultiplier.HasValue)
                range *= data.RangeMultiplier.Value;

            range += data.RangeBonus;

            return distanceType switch
            {
                DistanceType.CenterToCenter => Character.Distance(target) < range,
                DistanceType.EdgeToCenter => Character.EdgeToCenterDistance(target) < range,
                DistanceType.EdgeToEdge => Character.EdgeToEdgeDistance(target) < range,
                _ => throw new ArgumentOutOfRangeException(nameof(distanceType), distanceType, "Invalid distance type")
            };
        }

        /// <summary>
        ///     Checks if you are within range of an NPC, using a range depending on the NPC.
        /// </summary>
        /// <param name="npcId">The id of the NPC.</param>
        /// <exception cref="ArgumentNullException">npcId</exception>
        /// <exception cref="InvalidOperationException">Missing npc metadata for {npcId} </exception>
        public async ValueTask<bool> WithinRangeOfNPCAsync(string npcId)
        {
            if (string.IsNullOrEmpty(npcId))
                throw new ArgumentNullException(nameof(npcId));

            if (!await Players.TryGetValueAsync(npcId, out var npcTask).ConfigureAwait(false))
                return false;

            var nData = GameData.NPCs[npcId];

            if (nData == null)
                throw new InvalidOperationException($"Missing npc metadata for {npcId}");

            var range = CORE_CONSTANTS.NPC_RANGE;

            if (nData.Role == NPCRole.Transport)
                range = CORE_CONSTANTS.TRANSPORTER_RANGE;

            var npc = await npcTask.ConfigureAwait(false);

            return Character.Distance(npc).SignificantlyLessThan(range, CORE_CONSTANTS.EPSILON);
        }
        #endregion

        #region Connection stuff
        /// <summary>
        ///     Asynchronously connects to an Adventure.Land socket server.
        /// </summary>
        /// <param name="region">The region to connect to.</param>
        /// <param name="identifier">The identifier within the region to connect to.</param>
        /// <exception cref="InvalidOperationException">There is already an open socket in use. Try disposing it and reconnecting.</exception>
        /// <exception cref="InvalidOperationException">Character ""{Name}"" not found.</exception>
        /// <exception cref="InvalidOperationException">Server {region} {identifier} not found."</exception>
        public async Task ConnectAsync(ServerRegion region, ServerId identifier)
        {
            if (Socket.Connected)
                throw new InvalidOperationException("There is already an open socket in use. Try disposing it and reconnecting.");

            var serversAndCharacters = await API.GetServersAndCharactersAsync().ConfigureAwait(false);
            var charInfo = serversAndCharacters.Characters.FirstOrDefault(character => character.Name.EqualsI(Name));

            var serverInfo = serversAndCharacters.Servers.FirstOrDefault(server =>
                (server.Region == region) && (server.Identifier == identifier));

            if (charInfo == null)
                throw new InvalidOperationException($@"Character ""{Name}"" not found.");

            Identifier = charInfo.Id;
            Server = serverInfo ?? throw new InvalidOperationException($@"Server {region} {identifier} not found.");

            await Sync.WaitAsync().ConfigureAwait(false);

            try
            {
                await InternalConnectAsync().ConfigureAwait(false);
            } finally
            {
                Sync.Release();
            }
        }

        protected async Task InternalConnectAsync()
        {
            AttachListeners();

            var source = new TaskCompletionSource<Expectation<StartData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameErrorCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameError,
                    data => Task.FromResult(source.TrySetResult(data.Message)))
                .ConfigureAwait(false);

            await using var welcomeCallback = Socket.On<WelcomeData>(ALSocketMessageType.Welcome, async _ =>
                {
                    //dont await, seems to cause issues
                    await Socket.EmitAsync(ALSocketEmitType.Auth, new
                        {
                            auth = API.Auth.AuthKey,
                            character = Identifier,
                            height = 1080,
                            no_graphics = "true",
                            no_html = "1",
                            passphrase = string.Empty,
                            scale = 2,
                            user = API.Auth.UserID.ToString(),
                            width = 1920
                        })
                        .ConfigureAwait(false);

                    return false;
                })
                .ConfigureAwait(false);

            await using var startCallback = Socket.On<StartData>(ALSocketMessageType.Start, data =>
                {
                    source.TrySetResult(data);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.ConnectAsync(Server).ConfigureAwait(false);

            var result = await source.Task.WithTimeout(10000).ConfigureAwait(false);
            result.ThrowIfUnsuccessful();

            Socket.OnDisconnected += OnDisconnected;
            PositionManager.Start();
            PingManager.Start();
        }

        protected async Task ReconnectAsync()
        {
            try
            {
                await Socket.DisposeAsync().ConfigureAwait(false);
            } catch
            {
                //ignored
            }

            var logger = new FormattedLogger(Name, LogManager.GetLogger<ALSocketClient>());

            var reconnectCount = 0;

            while (reconnectCount < 10)
                try
                {
                    Socket = new ALSocketClient(logger);
                    Logger.Info($"Attemping to reconnect. (Retry: {++reconnectCount})");
                    await InternalConnectAsync().ConfigureAwait(false);

                    return;
                } catch
                {
                    Logger.Error("Reconnect failed, waiting 10s to retry...");
                    await Task.Delay(1000 * 10).ConfigureAwait(false);
                }

            Logger.Fatal("Reconnect attempts failed.");
            Environment.Exit(-1);
        }

        /// <summary>
        ///     <inheritdoc cref="ALSocketClient.DisconnectAsync" />
        /// </summary>
        public async Task DisconnectAsync()
        {
            await Sync.WaitAsync().ConfigureAwait(false);

            try
            {
                Logger.Warn("Disconnecting");
                await Socket.DisconnectAsync().ConfigureAwait(false);
            } finally
            {
                Sync.Release();
            }
        }
        #endregion

        #region Actions
        /// <summary>
        ///     Asynchronously accepts a magiport offer.
        /// </summary>
        /// <param name="from">The name of the character who offered the magiport.</param>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     Information about the map you got magiported to.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        public async Task AcceptMagiportAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, _ =>
                {
                    source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Magiport, new { name = from }).ConfigureAwait(false);
            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously accepts a party invite.
        /// </summary>
        /// <param name="from">The name of the character who invited you.</param>
        /// <exception cref="ArgumentNullException">from</exception>
        /// <exception cref="InvalidOperationException">Failed to accept party invite. ({reason})</exception>
        public async Task AcceptPartyInviteAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
                {
                    if (data.MemberNames.ContainsI(from))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var result = false;
                    var message = data.Message;

                    if (message.EqualsI("invitation expired") || message.EqualsI($"{from} is not found"))
                        result = source.TrySetResult($"Failed to accept party invite. ({message})");
                    else if (message.EqualsI("already partying"))
                        if (Party.Members.Count == 0)
                            result = source.TrySetResult($"Failed to accept party invite. ({message})");
                        else
                            result = Party.MemberNames.ContainsI(from)
                                ? source.TrySetResult(Expectation.Success)
                                : source.TrySetResult($"Failed to accept party invite. ({message})");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Party, new { @event = "accept", name = from }).ConfigureAwait(false);
            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously accepts a party request.
        /// </summary>
        /// <param name="from">The name of the character who requested the invite.</param>
        /// <exception cref="ArgumentNullException">from</exception>
        /// <exception cref="InvalidOperationException">Failed to accept party request. ({reason})</exception>
        public async Task AcceptPartyRequestAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
                {
                    if (data.MemberNames.ContainsI(from))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var result = false;
                    var message = data.Message;

                    if (message.EqualsI("request expired") || message.EqualsI($"Failed to accept party request. ({message})"))
                        result = source.TrySetResult(message);
                    else if (message.EqualsI("already partying"))
                        if (Party.Members.Count == 0)
                            result = source.TrySetResult($"Failed to accept party request. ({message})");
                        else
                            result = Party.MemberNames.ContainsI(from)
                                ? source.TrySetResult(Expectation.Success)
                                : source.TrySetResult($"Failed to accept party request. ({message})");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Party, new { @event = "raccept", name = from }).ConfigureAwait(false);
            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously attempts to attack a target.
        /// </summary>
        /// <param name="targetId">The id of the target to attack.</param>
        /// <returns>
        ///     <see cref="ActionData" /> <br />
        ///     Details about the action taken.
        /// </returns>
        /// <exception cref="ArgumentNullException">targetId</exception>
        /// <exception cref="InvalidOperationException">Attack on {targetId} failed. ({reason})</exception>
        public async Task<ActionData> AttackAsync(string targetId)
        {
            if (string.IsNullOrEmpty(targetId))
                throw new ArgumentNullException(nameof(targetId));

            var source = new TaskCompletionSource<Expectation<ActionData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var deathCallback = Socket.On<DeathData>(ALSocketMessageType.Death, data =>
                {
                    if (data.Id.EqualsI(targetId))
                        source.TrySetResult($"Attack on {targetId} failed. (target died)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.Disabled when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                            $"Attack on {targetId} failed. (disabled)"),
                        GameResponseType.AttackFailed when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                            $"Attack on {targetId} failed. (attack failed)"),
                        GameResponseType.TooFar when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                            $"Attack on {targetId} failed. (too far: {data.Distance:N2})"),
                        GameResponseType.Cooldown when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                            $"Attack on {targetId} failed. (on cooldown: {data.CooldownMS:N2}"),
                        GameResponseType.NoMP when data.Place == "attack" => source.TrySetResult(
                            $"Attack on {targetId} failed. (not enough mp)"),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var notThereCallback = Socket.On<NotThereData>(ALSocketMessageType.NotThere,
                    data => Task.FromResult(data.Source.EqualsI("attack")
                                            && source.TrySetResult($"Attack on {targetId} failed. (invalid target)")))
                .ConfigureAwait(false);

            await using var actionCallback = Socket.On<ActionData>(ALSocketMessageType.Action, data =>
                {
                    var result = false;

                    if (data.AttackerId.EqualsI(Character.Id) && data.Target.EqualsI(targetId) && data.Type.EqualsI("attack"))
                        result = source.TrySetResult(data);

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Attack, new { id = targetId }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from an NPC.
        /// </summary>
        /// <param name="itemName">The name of the item to buy.</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="SimpleItem" /> <br />
        ///     Basic information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <exception cref="InvalidOperationException">Quantity cannot be below 1.</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {itemName}. ({reason})</exception>
        public async Task<SimpleIndexer> BuyAsync(string itemName, int quantity = 1)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (quantity < 1)
                throw new InvalidOperationException("Quantity cannot be below 1.");

            var source = new TaskCompletionSource<Expectation<SimpleIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.BuySuccess => source.TrySetResult(new SimpleIndexer
                        {
                            Index = data.SlotNum,
                            Item = new SimpleItem
                            {
                                Name = data.Name!,
                                Quantity = data.Quantity
                            }
                        }),
                        GameResponseType.BuyCantNPC   => source.TrySetResult($"Failed to buy {itemName}. (wrong npc)"),
                        GameResponseType.BuyCantSpace => source.TrySetResult($"Failed to buy {itemName}. (not enough space)"),
                        GameResponseType.BuyCost      => source.TrySetResult($"Failed to buy {itemName}. (not enough gold)"),
                        GameResponseType.BuyGetCloser => source.TrySetResult($"Failed to buy {itemName}. (get closer: {data.Distance:N2})"),
                        _                             => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            if (GameData.Items[itemName]?.StackSize > 1)
                await Socket.EmitAsync(ALSocketEmitType.Buy, new { name = itemName, quantity }).ConfigureAwait(false);
            else
                await Socket.EmitAsync(ALSocketEmitType.Buy, new { name = itemName }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from a player.
        /// </summary>
        /// <param name="playerName">The name of the player to buy from.</param>
        /// <param name="slot">The slot the item is in.</param>
        /// <param name="item">The item to buy</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">playerName</exception>
        /// <exception cref="ArgumentNullException">item</exception>
        /// <exception cref="InvalidOperationException">{reason}</exception>
        public async Task<InventoryIndexer> BuyFromPlayerAsync(string playerName, TradeSlot slot, TradeItem item, int quantity = 1)
        {
            if (string.IsNullOrEmpty(playerName))
                throw new ArgumentNullException(nameof(playerName));

            if (item == null)
                throw new ArgumentNullException(nameof(item));

            Player player;

            if (!await Players.TryGetValueAsync(playerName, out var playerTask).ConfigureAwait(false)
                || ((player = await playerTask.ConfigureAwait(false)) == null))
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (seller gone)");

            if (Character.DistanceWithMapCheck(player) > CORE_CONSTANTS.NPC_RANGE)
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (get closer)");

            var slotItem = player.Slots[slot.ToSlot()];

            if ((slotItem == null) || (slotItem.Id != item.Id))
                throw new InvalidOperationException($"Failed to buy {item.Name} from {playerName}. (wrong id)");

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            var inventorySnapshot = Character.Inventory.AsIndexed();
            var existingTotal = Character.Inventory.CountOf(item.Name);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = false;

                    if (data.ResponseType == GameResponseType.TradeGetCloser)
                        result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. (get closer)");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var result = false;
                    var message = data.Message;

                    if (message.EqualsI("not enough gold") || message.EqualsI("you can't buy that many") || message.EqualsI("seller gone"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. ({message})");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from {playerName}. (no space)");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var newTotal = data.Inventory.CountOf(item.Name);

                    if (newTotal - existingTotal == quantity)
                        source.TrySetResult(data.Inventory.AsIndexed().Except(inventorySnapshot).First());

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.TradeBuy, new { slot, id = playerName, rid = item.Id, q = quantity.ToString() })
                .ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Attempts to buy an item from Ponty. <br />
        ///     Ponty sells items other players have sold to NPCs, but at a 20% markup.
        /// </summary>
        /// <param name="item">The item to buy.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">item</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {item.Name}. ({reason})</exception>
        public async Task<InventoryIndexer> BuyFromPontyAsync(TradeItem item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            var existingCount = Character.Inventory.CountOf(item.Name);
            var existingItems = Character.Inventory.AsIndexed();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = false;

                    if (data.ResponseType == GameResponseType.BuyCost)
                        result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. (not enough gold)");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var result = false;
                    var message = data.Message;

                    if (message.EqualsI("item gone"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. ({message})");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. ({data.Message})");

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var newCount = data.Inventory.CountOf(item.Name);

                    if (newCount - existingCount == Math.Max(1, item.Quantity))
                        source.TrySetResult(data.Inventory.AsIndexed().Except(existingItems).First());

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.SecondHandsBuy, new { rid = item.Id }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Attempts to compound 3 items of the same level/name.
        /// </summary>
        /// <param name="inventorySlot1">The inventory index of the first item.</param>
        /// <param name="inventorySlot2">The inventory index of the second item.</param>
        /// <param name="inventorySlot3">The inventory index of the third item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the compound succeeded, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to compound. ({reason})</exception>
        public async Task<bool> CompoundAsync(
            int inventorySlot1,
            int inventorySlot2,
            int inventorySlot3,
            int scrollIndex,
            int? offeringIndex = null)
        {
            var item = Character.Inventory[inventorySlot1];
            var source = new TaskCompletionSource<Expectation<bool?>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.MiscFail when data.Place.EqualsI("compound") => source.TrySetResult(
                            "Failed to compound. (misc, more than 1 issue)"),
                        //this actually occurs when "clevel" is set to the wrong value, but that should only happen if index1 is the wrong item, or no item.
                        GameResponseType.CompoundNoItem             => source.TrySetResult("Failed to compound. (items not the same)"),
                        GameResponseType.CompoundInProgress         => source.TrySetResult("Failed to compound. (already compounding)"),
                        GameResponseType.CompoundIncompatibleScroll => source.TrySetResult("Failed to compound. (wrong scroll)"),
                        GameResponseType.CompoundMismatch           => source.TrySetResult("Failed to compound. (items not the same)"),
                        GameResponseType.CompoundCant               => source.TrySetResult("Failed to compound. (items not compoundable)"),
                        GameResponseType.CompoundInvalidOffering => source.TrySetResult(
                            "Failed to compound. (offering is not an offering)"),
                        GameResponseType.Exception when data.Place.EqualsI("compound") => source.TrySetResult(
                            "Failed to compound. (exception, major issues)"),
                        GameResponseType.BankRestrictions => source.TrySetResult("Failed to compound. (can't compound from bank)"),
                        GameResponseType.ECUGetCloser     => source.TrySetResult("Failed to compound. (get closer)"),
                        GameResponseType.CompoundSuccess  => source.TrySetResult(true),
                        GameResponseType.CompoundFail     => source.TrySetResult(false),
                        _                                 => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Compound, new
                {
                    items = new[] { inventorySlot1, inventorySlot2, inventorySlot3 },
                    scroll_num = scrollIndex,
                    clevel = item?.Level ?? 0,
                    offering_num = offeringIndex
                })
                .ConfigureAwait(false);

            return await source.Task.WithTimeout(60000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Attempts to have the server calculate the chance for a compound to succeed.
        /// </summary>
        /// <param name="inventorySlot1">The inventory index of the first item.</param>
        /// <param name="inventorySlot2">The inventory index of the second item.</param>
        /// <param name="inventorySlot3">The inventory index of the third item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="ResponseItem" /> <br />
        ///     An object containing details about the item, and it's chance to successully be compounded.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to compound. ({reason})</exception>
        public async Task<ResponseItem> CompoundCalculateAsync(
            int inventorySlot1,
            int inventorySlot2,
            int inventorySlot3,
            int scrollIndex,
            int? offeringIndex = null)
        {
            var item = Character.Inventory[inventorySlot1];
            var source = new TaskCompletionSource<Expectation<ResponseItem>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.MiscFail when data.Place.EqualsI("compound") => source.TrySetResult(
                            "Failed to compound. (misc, more than 1 issue)"),
                        //this actually occurs when "clevel" is set to the wrong value, but that should only happen if index1 is the wrong item, or no item.
                        GameResponseType.CompoundNoItem             => source.TrySetResult("Failed to compound. (items not the same)"),
                        GameResponseType.CompoundInProgress         => source.TrySetResult("Failed to compound. (already compounding)"),
                        GameResponseType.CompoundIncompatibleScroll => source.TrySetResult("Failed to compound. (wrong scroll)"),
                        GameResponseType.CompoundMismatch           => source.TrySetResult("Failed to compound. (items not the same)"),
                        GameResponseType.CompoundCant               => source.TrySetResult("Failed to compound. (items not compoundable)"),
                        GameResponseType.CompoundInvalidOffering => source.TrySetResult(
                            "Failed to compound. (offering is not an offering)"),
                        GameResponseType.Exception when data.Place.EqualsI("compound") => source.TrySetResult(
                            "Failed to compound. (exception, major issues)"),
                        GameResponseType.BankRestrictions => source.TrySetResult("Failed to compound. (can't compound from bank)"),
                        GameResponseType.ECUGetCloser     => source.TrySetResult("Failed to compound. (get closer)"),
                        GameResponseType.CompoundChance when data.Item?.Name.EqualsI(item?.Name) ?? false => source.TrySetResult(
                            data.Item with
                            {
                                Grace = data.Grace,
                                Chance = data.Chance
                            }),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Compound, new
                {
                    items = new[] { inventorySlot1, inventorySlot2, inventorySlot3 },
                    scroll_num = scrollIndex,
                    clevel = item?.Level ?? 0,
                    offering_num = offeringIndex,
                    calculate = 1
                })
                .ConfigureAwait(false);

            return await source.Task.WithTimeout(60000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously crafts an item.
        /// </summary>
        /// <param name="itemName">The name of the item to craft.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     Information about the item that was crafted, and it's position in the inventory.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <exception cref="InvalidOperationException">Failed to craft {itemName}. ({reason})</exception>
        public async Task<InventoryIndexer> CraftAsync(string itemName)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            var recipe = GameData.Craft[itemName];

            if (recipe == null)
                throw new InvalidOperationException($"Failed to craft {itemName}. (not craftable)");

            if (recipe.Cost > Character.Gold)
                throw new InvalidOperationException($"Failed to craft {itemName}. (not enough gold)");

            var slots = new List<int>();

            foreach ((var quantity, var name, var level) in recipe.Items)
            {
                var result = Character.Inventory.FindItem(name, level, quantity);

                if (result == null)
                    throw new InvalidOperationException($"Failed to craft {itemName}. (missing component)");

                slots.Add(result.Index);
            }

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);
            var previousInventory = Character.Inventory.AsIndexed();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.NoItem        => source.TrySetResult($"Failed to craft {itemName}. (missing component)"),
                        GameResponseType.NotEnoughGold => source.TrySetResult($"Failed to craft {itemName}. (not enough gold"),
                        _                              => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var craftedItem = data.Inventory.AsIndexed()
                        .Except(previousInventory)
                        .FirstOrDefault(indexed => indexed.Item.Name.EqualsI(itemName));

                    if (craftedItem != null)
                        source.TrySetResult(craftedItem);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Craft, slots.Select((index, slot) => new[] { index, slot })).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously deposits gold in the bank.
        /// </summary>
        /// <param name="amount">The amount of gold to deposit.</param>
        /// <returns>
        ///     <see cref="int" /> <br />
        ///     The amount of gold the character has after depositing.
        /// </returns>
        public async Task DepositGoldAsync(long amount)
        {
            if (Character.Bank == null)
                throw new InvalidOperationException($"Failed to deposit {amount} gold. (not in bank)");

            var shouldChange = (amount > 0) && Character.Gold.SignificantlyGreaterThan(0, CORE_CONSTANTS.EPSILON);

            if (!shouldChange || (amount > (long)Character.Gold))
                throw new InvalidOperationException($"Failed to deposit {amount} gold. (invalid amount)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            var previousGold = Character.Gold;

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (data.Bank == null)
                        source.TrySetResult($"Failed to deposit {amount} gold. (not in bank)");

                    var didChange = !previousGold.NearlyEquals(data.Gold, CORE_CONSTANTS.EPSILON);

                    if (didChange)
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Bank, new { amount, operation = "deposit" }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously deposits an item in the bank.
        /// </summary>
        /// <param name="inventorySlot">The slot in the inventory the item is currently at.</param>
        /// <param name="bankPack">If specified, will try to find a slot in this bankPack to deposit the item.</param>
        /// <param name="bankSlot">
        ///     If specified with bankPack, will deposit the item in this bankPack, in this bankSlot if it is
        ///     empty.
        /// </param>
        /// <returns>
        ///     <see cref="BankIndexer" /> <br />
        ///     Information about the item and it's index in the bank.
        /// </returns>
        /// <exception cref="ArgumentException">If specifying bankSlot), must also specify bankPack.</exception>
        /// <exception cref="InvalidOperationException">Failed to deposit item {item}. ({reason})</exception>
        public async Task<BankIndexer> DepositItemAsync(int inventorySlot, BankPack? bankPack = null, int? bankSlot = null)
        {
            if ((bankSlot != null) && (bankPack == null))
                throw new ArgumentException($"If specifying {nameof(bankSlot)}, must also specify {nameof(bankPack)}.");

            if (Character.Bank == null)
                throw new InvalidOperationException($"Failed to deposit item {inventorySlot}. (not in bank)");

            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to deposit item. (no item in slot {inventorySlot})");

            var indexedItem = new InventoryIndexer { Index = inventorySlot, Item = item };
            var optimalIndexes = FindOptimalBankIndex(indexedItem, bankPack, bankSlot);

            if (optimalIndexes == null)
                throw new InvalidOperationException($"Failed to deposit item {item.Name}. (no space)");

            (bankPack, bankSlot) = optimalIndexes.Value;
            var source = new TaskCompletionSource<Expectation<BankIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    if (data.ResponseType == GameResponseType.Invalid)
                        source.TrySetResult($"Failed to deposit item {item.Name}. (invalid)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (data.Bank == null)
                        source.TrySetResult($"Failed to deposit item {item.Name}. (not in bank)");
                    else if ((data.Inventory[inventorySlot] == null) && data.Bank.TryGetValue(bankPack.Value, out var bankedItems))
                    {
                        var probableIndex = bankedItems.FindIndex(b =>
                            (b != null) && b.Name.EqualsI(item.Name) && (b.Level == item.Level) && (b.Quantity >= item.Quantity));

                        if (probableIndex == -1)
                            return TaskCache.FALSE;
                        
                        var bankedItem = bankedItems[probableIndex]!;
                        source.TrySetResult(new BankIndexer { BankPack = bankPack.Value, Index = probableIndex, Item = bankedItem });
                    }

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Bank, new
                {
                    operation = "swap", inv = inventorySlot,
                    str = bankSlot.Value, pack = bankPack.Value.ToString().ToLower()
                })
                .ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously equips an item in a slot.
        /// </summary>
        /// <param name="inventorySlot">The slot in the inventory of the item to equip.</param>
        /// <param name="slot">The slot to equip the item into.</param>
        /// <exception cref="InvalidOperationException">Failed to equip item {itemNameOrSlot}. ({reason})</exception>
        public async Task EquipAsync(int inventorySlot, Slot slot)
        {
            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to equip item {inventorySlot}. (slot is empty)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    if (data.Id.EqualsI(Name) && data.Message.EqualsI("can't equip"))
                        source.TrySetResult($"Failed to equip item {item.Name}. (wrong slot)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var slotItem = data.Slots[slot];

                    if ((slotItem != null) && slotItem.Name.EqualsI(item.Name) && (slotItem.Level == item.Level))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Equip, new { num = inventorySlot, slot }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously attempts to exchange an item.
        /// </summary>
        /// <param name="inventorySlot">The index of the item to exchange.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     The item received from the exchange.
        /// </returns>
        /// <exception cref="InvalidOperationException"></exception>
        public async Task<InventoryIndexer> ExchangeAsync(int inventorySlot)
        {
            if (inventorySlot >= Character.InventorySize)
                throw new InvalidOperationException("Failed to exchange. (index out of range)");

            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException("Failed to exchange. (no item at index)");

            var itemData = item.GetData();

            if (itemData == null)
                throw new InvalidOperationException("Failed to exchange. (no data, contact me)");

            if ((itemData.ExchangeAtNPC == null) || !itemData.ExchangeCount.HasValue)
                throw new InvalidOperationException("Failed to exchange. (item not exchangeable)");

            if (itemData.ExchangeCount > item.Quantity)
                throw new InvalidOperationException($"Failed to exchange. (you do not have {itemData.ExchangeCount})");

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.ExchangeNotEnough => source.TrySetResult(
                            $"Failed to exchange. (youd to not have {itemData.ExchangeCount})"),
                        GameResponseType.ECUGetCloser     => source.TrySetResult("Failed to exchange. (get closer)"),
                        GameResponseType.ExchangeExisting => source.TrySetResult("Failed to exchange. (already exchanging)"),
                        GameResponseType.BankRestrictions => source.TrySetResult("Failed to exchange. (can't exchange from bank)"),
                        _                                 => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            var exchangeStarted = false;
            Inventory? itemsSnapshot = null;

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (!exchangeStarted
                        && (data.QueuedActions?.Exchange != null)
                        && data.QueuedActions.Exchange.CurrentMS.NearlyEquals(data.QueuedActions.Exchange.LengthMS, CORE_CONSTANTS.EPSILON))
                        exchangeStarted = true;

                    if (exchangeStarted)
                    {
                        if (data.QueuedActions?.Exchange == null)
                            source.TrySetResult(Character.Inventory.AsIndexed().Except(itemsSnapshot!.AsIndexed()).First());
                        else
                            itemsSnapshot = Character.Inventory;
                    }

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Exchange, new
                {
                    item_num = inventorySlot,
                    q = itemData.ExchangeCount
                })
                .ConfigureAwait(false);

            return await source.Task.WithTimeout(60000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously leaves the map. (this is needed to leave an irregular map like cyberland)
        /// </summary>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     The data of the map you teleported to by leaving.
        /// </returns>
        public async Task LeaveMapAsync()
        {
            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.CantEscape => source.TrySetResult("Failed to leave map. (can't escape)"),
                        _                           => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, _ =>
                {
                    source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.LeaveMap).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously leaves the party.
        /// </summary>
        public async Task LeavePartyAsync()
        {
            var source = new TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, _ =>
                {
                    source.TrySetResult();

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Party, new { @event = "leave" }).ConfigureAwait(false);

            await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously begins or completes a monsterhunt quest.
        /// </summary>
        /// <exception cref="InvalidOperationException">Failed to monsterhunt. ({reason})</exception>
        public async Task MonsterHuntAsync()
        {
            if (await Character.Conditions.TryGetValueAsync(Condition.MonsterHunt, out var conditionTask).ConfigureAwait(false))
            {
                var condition = await conditionTask.ConfigureAwait(false);

                if ((condition.RemainingMS > 0) && (condition.RemainingMonsters > 0))
                    throw new InvalidOperationException("Failed to monsterhunt. (monsterhunt in progress)");
            }

            var source = new TaskCompletionSource<Expectation<bool?>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.ECUGetCloser        => source.TrySetResult("Failed to monsterhunt. (get closer)"),
                        GameResponseType.MonsterHuntStarted  => source.TrySetResult(true),
                        GameResponseType.MonsterHuntMerchant => source.TrySetResult("Failed to monsterhunt. (merchants can't monsterhunt)"),
                        _                                    => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.MonsterHunt).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously moves to a given point.
        /// </summary>
        /// <param name="point">The point to move to.</param>
        /// <param name="token">A token used to cancel this action.</param>
        /// <returns>
        ///     <see cref="IPoint" /> <br />
        ///     The point we ended up on after this operation either completed, failed, or was canceled.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to move to {point}. ({reason})</exception>
        [SuppressMessage("ReSharper", "AccessToModifiedClosure"), SuppressMessage("ReSharper", "AccessToDisposedClosure")]
        public async Task MoveAsync(IPoint point, CancellationToken? token = null)
        {
            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            var currentMap = Character.Map;
            var startLoc = new Location(Character.Map, Character.ToPoint());
            DateTime? setMovingAt = default;
            var correctionAttempted = false;

            using var delay = new DynamicDelay();

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, async data =>
                {
                    if (!setMovingAt.HasValue)
                        return false;

                    var now = DateTime.UtcNow;
                    var elapsed = now.Subtract(setMovingAt.Value).TotalMilliseconds;

                    //if the movement data doesnt look right
                    if (!data.Moving
                        || !data.GoingX.NearlyEquals(point.X, CORE_CONSTANTS.EPSILON)
                        || !data.GoingY.NearlyEquals(point.Y, CORE_CONSTANTS.EPSILON))
                    {
                        //if we already tried to request new movement data
                        if (correctionAttempted)
                        {
                            //set a failure result
                            source.TrySetResult($"Failed to move to {point.ToPoint()}. (desync/packetloss)");

                            return false;
                        }

                        //if we should have reasonably received correct movement data
                        if (elapsed > PingManager.Offset * 2)
                        {
                            //request new movement data from the server
                            Logger.Debug("Correcting position");
                            _ = Socket.EmitAsync(ALSocketEmitType.Property, new { typing = true }).ConfigureAwait(false);
                            correctionAttempted = true;
                        }
                        //this could be some other random character data, just set it's movement data to the correct stuff
                        else
                            Character.SetMoving(point);
                    }

                    await delay.SetDelayAsync(Convert.ToInt32(Character.Distance(point) / Character.Speed * 1000)).ConfigureAwait(false);

                    /*
                    switch (correctionAttempted)
                    {
                        case true when shouldBeMoving && (!data.Moving
                                       || !data.GoingX.NearlyEquals(point.X, CORE_CONSTANTS.EPSILON)
                                       || !data.GoingY.NearlyEquals(point.Y, CORE_CONSTANTS.EPSILON)):
                            source.TrySetResult($"Failed to move to {point.ToPoint()}. (desync/packetloss)");
    
                            return false;
                        case false when !data.Moving
                                        || !data.GoingX.NearlyEquals(point.X, CORE_CONSTANTS.EPSILON)
                                        || !data.GoingY.NearlyEquals(point.Y, CORE_CONSTANTS.EPSILON):
                            correctionAttempted = true;
    
                            Logger.Debug("Correcting position");
                            await Socket.EmitAsync(ALSocketEmitType.Property, new { typing = true }).ConfigureAwait(false);
    
                            break;
                    }*/

                    // ReSharper disable once AccessToDisposedClosure - this action is safe even if disposed

                    return false;
                })
                .ConfigureAwait(false);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, data =>
                {
                    var goingLoc = new Location(currentMap, point);

                    if (data.Map.EqualsI("jail"))
                    {
                        var standingLocation = Character.ToLocation();
                        var standingOnWall = PathFinder.IsWall(standingLocation);
                        var goingLocation = new Location(Character.Map, Character.GoingX, Character.GoingY);
                        var validPath = PathFinder.CanMove(standingLocation, goingLocation);

                        source.TrySetResult(
                            $"Sent to jail from {startLoc} (IsWall: {standingOnWall}), moving to {goingLoc} (Valid: {validPath})");
                    }

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Move, new
                {
                    x = Character.X,
                    y = Character.Y,
                    going_x = point.X,
                    going_y = point.Y,
                    m = Character.MapChangeCount
                })
                .ConfigureAwait(false);

            var initialDelay = Convert.ToInt32(Character.Distance(point) / Character.Speed * 1000);
            Character.SetMoving(point);
            setMovingAt = DateTime.UtcNow;

            var delayTask = delay.WaitAsync(initialDelay, token);
            var completedTask = await Task.WhenAny(delayTask, source.Task).ConfigureAwait(false);

            //if cancellation is requested, emit a walk to where we're already standing.
            if (token?.IsCancellationRequested == true)
            {
                var finalDestination = Character.ToPoint();
                Logger.Debug($"Move to {point.ToPoint()} canceled. Stopping at {finalDestination}");
                point = finalDestination;

                await Socket.EmitAsync(ALSocketEmitType.Move, new
                    {
                        x = Character.X,
                        y = Character.Y,
                        going_x = point.X,
                        going_y = point.Y,
                        m = Character.MapChangeCount
                    })
                    .ConfigureAwait(false);

                return;
            }

            //find out where we're going
            var going = new Point(Character.GoingX, Character.GoingY);

            //if we're still going to the same place
            if (going.Equals(point))
            {
                //if the task that completed was the source task, throw if it was an error
                if (completedTask != delayTask)
                {
                    var expectation = await source.Task.ConfigureAwait(false);
                    expectation.ThrowIfUnsuccessful();
                }

                Character.StopMoving();
                Character.UpdateLocation(going);
            }
        }

        /// <summary>
        ///     Asynchronously opens a chest.
        /// </summary>
        /// <param name="chestId">The id of the chest.</param>
        /// <returns>
        ///     <see cref="ChestOpenedData" /> <br />
        ///     Information about what was in the chest.
        /// </returns>
        /// <exception cref="ArgumentNullException">chestId</exception>
        /// <exception cref="InvalidOperationException">Failed to open chest {chestId}. ({reason})</exception>
        public async Task<ChestOpenedData> OpenChestAsync(string chestId)
        {
            if (string.IsNullOrEmpty(chestId))
                throw new ArgumentNullException(nameof(chestId));

            var source = new TaskCompletionSource<Expectation<ChestOpenedData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var chestOpenedCallback = Socket.On<ChestOpenedData>(ALSocketMessageType.ChestOpened, data =>
                {
                    if (data.Id.EqualsI(chestId))
                        if (data.Gone)
                            source.TrySetResult($"Failed to open chest {chestId}. (no chest)");
                        else
                            source.TrySetResult(data);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.OpenChest, new { id = chestId }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously pings the server.
        /// </summary>
        /// <param name="pingCount">The current ping count.</param>
        /// <returns>
        ///     <see cref="PingAckData" /> <br />
        ///     The ping acknowledgement from the server.
        /// </returns>
        public async Task<PingAckData> PingAsync(long pingCount)
        {
            var source = new TaskCompletionSource<Expectation<PingAckData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var pingAckCallback = Socket
                .On<PingAckData>(ALSocketMessageType.PingAck, data => Task.FromResult(source.TrySetResult(data)))
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Ping, new { id = pingCount.ToString() }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously requests your character's data from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="CharacterData" /> <br />
        ///     The character's data.
        /// </returns>
        public async Task<CharacterData> RequestCharacterAsync()
        {
            var source = new TaskCompletionSource<Expectation<CharacterData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    source.TrySetResult(data);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Property, new { typing = true }).ConfigureAwait(false);

            //return await source.Task.WithNetworkTimeout();
            return await source.Task.WithTimeout(5000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously requests a full entity refresh from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="EntitiesData" /> <br />
        ///     A full refresh of entity data.
        /// </returns>
        public async Task<EntitiesData> RequestEntitiesAsync()
        {
            var source = new TaskCompletionSource<Expectation<EntitiesData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var entitiesCallback = Socket.On<EntitiesData>(ALSocketMessageType.Entities,
                    data => Task.FromResult(source.TrySetResult(data)))
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.SendUpdates, new object()).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously fetches basic information about all players on the server.
        /// </summary>
        /// <returns>
        ///     <see cref="IReadOnlyList{T}" /> of <see cref="ISimplePlayer" /> <br />
        ///     Basic information about all players on the server.
        /// </returns>
        public async Task<IReadOnlyList<SimplePlayer>> RequestPlayersAsync()
        {
            var source = new TaskCompletionSource<Expectation<IReadOnlyList<SimplePlayer>>>(TaskCreationOptions
                .RunContinuationsAsynchronously);

            await using var playersCallback = Socket.On<IReadOnlyList<SimplePlayer>>(ALSocketMessageType.Players,
                    data => Task.FromResult(source.TrySetResult(new Expectation<IReadOnlyList<SimplePlayer>>(data))))
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Players).ConfigureAwait(false);

            return (await source.Task.WithNetworkTimeout().ConfigureAwait(false)).Result;
        }

        /// <summary>
        ///     Asynchronously gets a list of items ponty is selling.
        /// </summary>
        /// <returns>
        ///     <see cref="IReadOnlyList{T}" /> of <see cref="TradeItem" /> <br />
        ///     A list of items ponty is selling.
        /// </returns>
        public async Task<IReadOnlyList<TradeItem>> RequestPontyItemsAsync()
        {
            var source = new TaskCompletionSource<Expectation<IReadOnlyList<TradeItem>>>(TaskCreationOptions
                .RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.ECUGetCloser => source.TrySetResult("Failed to get ponty items. (get closer)"),
                        _                             => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var onSecondHandsCallback = Socket.On<TradeItem[]>(ALSocketMessageType.SecondHands, data =>
                {
                    source.TrySetResult(data);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.SecondHands).ConfigureAwait(false);

            return (await source.Task.WithNetworkTimeout().ConfigureAwait(false)).Result;
        }

        /// <summary>
        ///     Asynchronously attempts to respawn if dead.
        /// </summary>
        /// <exception cref="InvalidOperationException">Failed to respawn. ({reason})</exception>
        public async Task RespawnAsync()
        {
            if (!Character.RIP)
                throw new InvalidOperationException("Failed to respawn. (not dead)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var message = data.Message;

                    if (message.EqualsI("can't respawn yet."))
                        source.TrySetResult("Failed to respawn. (too soon)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, data =>
                {
                    if (data.Effect == DisappearEffect.Town)
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Respawn).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously sells an item.
        /// </summary>
        /// <param name="inventorySlot">The inventory slot of the item to sell.</param>
        /// <param name="quantity">The quantity to sell.</param>
        /// <exception cref="InvalidOperationException">Failed to sell item {nameOrSlot}. ({reason})</exception>
        public async Task SellItemAsync(int inventorySlot, int quantity)
        {
            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to sell item {inventorySlot}. (no item)");

            if ((item.Quantity < quantity) || (quantity <= 0))
                throw new InvalidOperationException($"Failed to sell item {item.Name}. (invalid quantity)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);
            var previousQuantity = Character.Inventory.CountOf(item.Name);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.BankRestrictions =>
                            source.TrySetResult($"Failed to sell item {item.Name}. (can't sell from bank)"),
                        GameResponseType.SellGetCloser => source.TrySetResult($"Failed to sell item {item.Name}. (get closer)"),
                        _                              => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var newQuantity = data.Inventory.CountOf(item.Name);

                    if (newQuantity == previousQuantity - quantity)
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Sell, new { num = inventorySlot, quantity }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously sends gold to a player.
        /// </summary>
        /// <param name="amount">The amount of gold to send.</param>
        /// <param name="toPlayerId">The id of the player to send gold to.</param>
        /// <param name="distanceCheck">Whether or not to check distance.</param>
        /// <exception cref="ArgumentNullException">toPlayerId</exception>
        /// <exception cref="InvalidOperationException">Failed to send {amount} gold to {toPlayerId}. ({reason})</exception>
        public async Task SendGoldAsync(long amount, string toPlayerId, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(toPlayerId))
                throw new ArgumentNullException(nameof(toPlayerId));

            var shouldChange = (amount > 0) && Character.Gold.SignificantlyGreaterThan(0, CORE_CONSTANTS.EPSILON);

            if (!shouldChange || (amount > (long)Character.Gold))
                throw new InvalidOperationException($"Failed to send {amount} gold to {toPlayerId}. (invalid amount)");

            if (distanceCheck)
            {
                if (!await Players.TryGetValueAsync(toPlayerId, out var toPlayerTask).ConfigureAwait(false))
                    throw new InvalidOperationException($"Failed to send {amount} gold to {toPlayerId}. (get closer)");

                var player = await toPlayerTask.ConfigureAwait(false);

                if (Character.DistanceWithMapCheck(player) > CORE_CONSTANTS.NPC_RANGE)
                    throw new InvalidOperationException($"Failed to send {amount} gold to {toPlayerId}. (get closer)");
            }

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);
            var previousGold = Character.Gold;

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.OperationUnavailable => source.TrySetResult(
                            $"Failed to send {amount} gold to {toPlayerId}. (target not online)"),
                        GameResponseType.TradeGetCloser => source.TrySetResult(
                            $"Failed to send {amount} gold to {toPlayerId}. (get closer)"),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var didChange = !previousGold.NearlyEquals(data.Gold, CORE_CONSTANTS.EPSILON);

                    if (shouldChange && didChange && data.Gold.SignificantlyLessThan(previousGold, CORE_CONSTANTS.EPSILON))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Send, new { gold = amount, name = toPlayerId }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously sends an item to a player.
        /// </summary>
        /// <param name="inventorySlot">The slot of the item to send.</param>
        /// <param name="toPlayerId">The id of the player to send to.</param>
        /// <param name="quantity">The quantity of the item to send.</param>
        /// <param name="distanceCheck">Whether or not to perform a distance check.</param>
        /// <exception cref="ArgumentNullException">toPlayerId</exception>
        /// <exception cref="ArgumentOutOfRangeException">quantity</exception>
        /// <exception cref="InvalidOperationException">
        ///     Failed to send {quantity} of item {itemNameOrSlot} to {toPlayerId}.
        ///     ({reason})
        /// </exception>
        public async Task SendItemAsync(int inventorySlot, string toPlayerId, int quantity = 1, bool distanceCheck = true)
        {
            if (string.IsNullOrEmpty(toPlayerId))
                throw new ArgumentNullException(nameof(toPlayerId));

            if (quantity <= 0)
                throw new ArgumentOutOfRangeException(nameof(quantity));

            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to send {quantity} of item {inventorySlot} to {toPlayerId}. (no item)");

            if (item.Quantity < quantity)
                throw new InvalidOperationException($"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (invalid quantity)");

            if (distanceCheck)
            {
                if (!await Players.TryGetValueAsync(toPlayerId, out var toPlayerTask).ConfigureAwait(false))
                    throw new InvalidOperationException($"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (get closer)");

                var toPlayer = await toPlayerTask.ConfigureAwait(false);

                if (Character.DistanceWithMapCheck(toPlayer) > CORE_CONSTANTS.NPC_RANGE)
                    throw new InvalidOperationException($"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (get closer)");
            }

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.SendNoItem => source.TrySetResult(
                            $"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (no item)"),
                        GameResponseType.SendNoSpace => source.TrySetResult(
                            $"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (target no space)"),
                        GameResponseType.TradeGetCloser => source.TrySetResult(
                            $"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (get closer)"),
                        GameResponseType.OperationUnavailable => source.TrySetResult(
                            $"Failed to send {quantity} of item {item.Name} to {toPlayerId}. (target not online)"),
                        //this is ok because it happens after we receive new player data
                        GameResponseType.ItemSent when data.Name.EqualsI(toPlayerId)
                                                       && (data.Item?.Name.EqualsI(item.Name) == true)
                                                       && (data.Quantity == quantity) => source.TrySetResult(Expectation.Success),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Send, new { name = toPlayerId, num = inventorySlot, q = quantity })
                .ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously sends a party invite.
        /// </summary>
        /// <param name="name">The name of the person to invite.</param>
        /// <exception cref="ArgumentNullException">name</exception>
        public async Task SendPartyInviteAsync(string name)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentNullException(nameof(name));

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameLogCallback = Socket.On<GameMessageData>(ALSocketMessageType.GameLog, data =>
                {
                    var message = data.Message;

                    if (message.EqualsI($"invited {name} to party"))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Party, new { @event = "invite", name }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously begins moving to a point on the current map that may or may not require complex pathfinding.
        /// </summary>
        /// <param name="point">The point to walk to.</param>
        /// <param name="distance">The distance from the location that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">locations</exception>
        public Task SmartMoveAsync(
            IPoint point,
            float distance = 0,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null) =>
            SmartMoveAsync(new[] { new MapCircle(new Location(Character.Map, point), distance) }, useTownIfOptimal, cancellationToken);

        /// <summary>
        ///     Asynchronously begins moving to any number of points on the current map that may or may not require complex
        ///     pathfinding.
        /// </summary>
        /// <param name="endPoints">A collection of potential end points on the current map.</param>
        /// <param name="distance">The distance from the point that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">locations</exception>
        public Task SmartMoveAsync(
            IEnumerable<IPoint> endPoints,
            float distance = 0,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null) =>
            SmartMoveAsync(endPoints.Select(point => new MapCircle(new Location(Character.Map, point), distance)), useTownIfOptimal,
                cancellationToken);

        /// <summary>
        ///     Asynchronously begins moving to a location that may or may not require complex pathfinding.
        /// </summary>
        /// <param name="location">The location to walk to.</param>
        /// <param name="distance">The distance from the location that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">locations</exception>
        public Task SmartMoveAsync(
            ILocation location,
            float distance = 0,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null) =>
            SmartMoveAsync(new[] { new MapCircle(location, distance) }, useTownIfOptimal, cancellationToken);

        /// <summary>
        ///     Asynchronously begins moving to any number of points on the current map that may or may not require complex
        ///     pathfinding.
        /// </summary>
        /// <param name="endLocations">A collection of potential end locations.</param>
        /// <param name="distance">The distance from the point that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">locations</exception>
        public Task SmartMoveAsync(
            IEnumerable<ILocation> endLocations,
            float distance = 0,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null) =>
            SmartMoveAsync(endLocations.Select(l => new MapCircle(l, distance)), useTownIfOptimal, cancellationToken);

        /// <summary>
        ///     Asynchronously moves to an number of locations that may or may not require complex pathfinding.
        /// </summary>
        /// <param name="endDestinations">A collection of potential end locations.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">locations</exception>
        public async Task SmartMoveAsync<T>(
            IEnumerable<T> endDestinations,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null) where T: ILocation, ICircle
        {
            if (endDestinations.Equals(default))
                throw new ArgumentNullException(nameof(endDestinations));

            // ReSharper disable once SwitchExpressionHandlesSomeKnownEnumValuesWithExceptionInDefault
            Task HandlePathConnectorAsync(IConnector<Point> pathConnector, CancellationToken? innerToken = null) =>
                pathConnector.Type switch
                {
                    ConnectorType.Walk => MoveAsync(pathConnector.End, innerToken),
                    ConnectorType.Town => UseTownAsync(innerToken),
                    _                  => throw new ArgumentOutOfRangeException($"Unexpected path connectorType: {pathConnector.Type}")
                };

            var ends = endDestinations.ToArray();

            if (ends.Length == 0)
                throw new ArgumentNullException(nameof(endDestinations));

            var route = PathFinder.FindRoute(Character.Map,
                ends.Select(destination => destination.Map).Distinct(StringComparer.OrdinalIgnoreCase).ToArray());

            await foreach (var routeConnector in route.ConfigureAwait(false))
            {
                if (cancellationToken?.IsCancellationRequested == true)
                    return;

                if (routeConnector.Type == ConnectorType.Leave)
                {
                    await LeaveMapAsync().ConfigureAwait(false);

                    continue;
                }

                var exits = routeConnector.Start.Exits.Where(exit => exit.ToLocation.Map.EqualsI(routeConnector.End.Accessor)).ToArray();
                var currentPoint = Character.ToPoint();
                var innerPath = PathFinder.FindPath(Character.Map, currentPoint, exits, useTownIfOptimal: useTownIfOptimal);
                RecurseWithoutTowning1:

                await foreach (var pathConnector in innerPath.ConfigureAwait(false))
                {
                    try
                    {
                        await HandlePathConnectorAsync(pathConnector, cancellationToken).ConfigureAwait(false);
                    } catch (Exception e)
                    {
                        if (e.Message.ContainsI("failed to town"))
                        {
                            innerPath = PathFinder.FindPath(Character.Map, currentPoint, exits, useTownIfOptimal: false);

                            goto RecurseWithoutTowning1;
                        }

                        throw;
                    }

                    currentPoint = pathConnector.End;

                    if (cancellationToken is { IsCancellationRequested: true })
                        return;
                }

                var destination = exits.MinBy(exit => exit.Distance(currentPoint))!;
                await TransportAsync(destination.ToLocation.Map, destination.ToSpawnIndex).ConfigureAwait(false);
            }

            var path = PathFinder.FindPath(Character.Map, Character.ToPoint(),
                ends.Where(destination => destination.Map.EqualsI(Character.Map)).Cast<ICircle>(), useTownIfOptimal: useTownIfOptimal);

            RecurseWithoutTowning2:

            await foreach (var pathConnector in path.ConfigureAwait(false))
            {
                try
                {
                    await HandlePathConnectorAsync(pathConnector, cancellationToken).ConfigureAwait(false);
                } catch (Exception e)
                {
                    if (e.Message.ContainsI("failed to town"))
                    {
                        path = PathFinder.FindPath(Character.Map, Character.ToPoint(),
                            ends.Where(destination => destination.Map.EqualsI(Character.Map)).Cast<ICircle>(), useTownIfOptimal: false);

                        goto RecurseWithoutTowning2;
                    }

                    throw;
                }

                if (cancellationToken is { IsCancellationRequested: true })
                    return;
            }
        }

        /// <summary>
        ///     Asynchronously moves to the first spawn of a given map.
        /// </summary>
        /// <param name="mapName">The name of the map to move to.</param>
        /// <param name="distance">The distance from the point that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">npcId</exception>
        /// <exception cref="InvalidOperationException">Missing npc metadata for {npcId}</exception>
        public Task SmartMoveToMapAsync(
            string mapName,
            float distance = 0f,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null)
        {
            if (string.IsNullOrEmpty(mapName))
                throw new ArgumentNullException(nameof(mapName));

            var mData = GameData.Maps[mapName];

            if (mData == null)
                throw new InvalidOperationException($"Missing map metadata for {mapName}");

            var spawn1 = mData.Spawns[0];
            var spawnLoc = new Location(mapName, spawn1);

            return SmartMoveAsync(spawnLoc, distance, useTownIfOptimal, cancellationToken);
        }

        /// <summary>
        ///     Asynchronously moves to the closest monster spawn for a given monster name.
        /// </summary>
        /// <param name="monsterName">The name of the monster whose spawn to move to.</param>
        /// <param name="pickRandomSpawn">Changes the behavior from closest spawn to random spawn.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">monsterName</exception>
        /// <exception cref="InvalidOperationException">Missing monster metadata for {monsterName}</exception>
        public Task SmartMoveToMonsterAsync(
            string monsterName,
            bool pickRandomSpawn = false,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null)
        {
            if (string.IsNullOrEmpty(monsterName))
                throw new ArgumentNullException(nameof(monsterName));

            var mData = GameData.Monsters[monsterName];

            if (mData == null)
                throw new InvalidOperationException($"Missing monster metadata for {monsterName}");

            var spawnAreas = mData.SpawnAreas;

            if (pickRandomSpawn)
            {
                var fr = new FastRandom();
                spawnAreas = spawnAreas.OrderBy(_ => fr.Next()).Take(1).ToList();
            }

            return SmartMoveAsync(spawnAreas, useTownIfOptimal, cancellationToken);
        }

        /// <summary>
        ///     Asynchronously moves to the closest possible location for a given npc id.
        /// </summary>
        /// <param name="npcId">The name of the npc to move to.</param>
        /// <param name="distance">The distance from the point that it is acceptable to stop at.</param>
        /// <param name="useTownIfOptimal">Whether or not to consider using town ability.</param>
        /// <param name="cancellationToken">A token used to cancel this action.</param>
        /// <exception cref="ArgumentNullException">npcId</exception>
        /// <exception cref="InvalidOperationException">Missing npc metadata for {npcId}</exception>
        public Task SmartMoveToNPCAsync(
            string npcId,
            float distance = CORE_CONSTANTS.NPC_RANGE,
            bool useTownIfOptimal = true,
            CancellationToken? cancellationToken = null)
        {
            if (string.IsNullOrEmpty(npcId))
                throw new ArgumentNullException(nameof(npcId));

            var nData = GameData.NPCs[npcId];

            if (nData == null)
                throw new InvalidOperationException($"Missing npc metadata for {npcId}");

            return SmartMoveAsync(nData.Locations, distance, useTownIfOptimal, cancellationToken);
        }

        /// <summary>
        ///     Asynchronously swaps the items between two bank slots, or moves an item from one slot to another.
        /// </summary>
        /// <param name="bankPack">The bankpack whose slots are to be swapped.</param>
        /// <param name="bankSlot1">A slot index within the inventory.</param>
        /// <param name="bankSlot2">A slot index within the inventory.</param>
        /// <exception cref="ArgumentOutOfRangeException">bankSlot1</exception>
        /// <exception cref="ArgumentOutOfRangeException">bankSlot2</exception>
        /// <exception cref="InvalidOperationException">Failed to swap bank slots {bankSlot1} and {bankSlot2}. ({reason})</exception>
        public async Task SwapBankSlotsAsync(BankPack bankPack, int bankSlot1, int bankSlot2)
        {
            if (Character.Bank == null)
                throw new InvalidOperationException($"Failed to swap bank slots {bankSlot1} and {bankSlot2}. (not in bank)");

            if (!Character.Bank.TryGetValue(bankPack, out var bank))
                throw new InvalidOperationException($"Failed to swap bank slots {bankSlot1} and {bankSlot2}. (bank unavailable)");

            if ((bankSlot1 < 0) || (bankSlot1 >= bank.Count))
                throw new ArgumentOutOfRangeException(nameof(bankSlot1));

            if ((bankSlot2 < 0) || (bankSlot2 >= bank.Count))
                throw new ArgumentOutOfRangeException(nameof(bankSlot2));

            var item1 = bank[bankSlot1];
            var item2 = bank[bankSlot2];

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (data.Bank == null)
                        return TaskCache.FALSE;

                    if (!data.Bank.TryGetValue(bankPack, out var cBank))
                        return TaskCache.FALSE;

                    var cItem1 = cBank[bankSlot1];
                    var cItem2 = cBank[bankSlot2];

                    if ((cItem1 == item2) && (cItem2 == item1))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Bank, new
                {
                    operation = "move",
                    a = bankSlot1,
                    b = bankSlot2,
                    pack = bankPack
                })
                .ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously swaps the items between two inventory slots, or moves an item from one slot to another.
        /// </summary>
        /// <param name="inventorySlot1">A slot index within the inventory.</param>
        /// <param name="inventorySlot2">A slot index within the inventory.</param>
        /// <exception cref="ArgumentOutOfRangeException">inventorySlot1</exception>
        /// <exception cref="ArgumentOutOfRangeException">inventorySlot2</exception>
        public async Task SwapInventorySlotsAsync(int inventorySlot1, int inventorySlot2)
        {
            if ((inventorySlot1 < 0) || (inventorySlot1 >= Character.InventorySize))
                throw new ArgumentOutOfRangeException(nameof(inventorySlot1));

            if ((inventorySlot2 < 0) || (inventorySlot2 >= Character.InventorySize))
                throw new ArgumentOutOfRangeException(nameof(inventorySlot2));

            var item1 = Character.Inventory[inventorySlot1];
            var item2 = Character.Inventory[inventorySlot2];

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var cItem1 = data.Inventory[inventorySlot1];
                    var cItem2 = data.Inventory[inventorySlot2];

                    if ((cItem1 == item2) && (cItem2 == item1))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.InventoryMove, new
                {
                    a = inventorySlot1,
                    b = inventorySlot2
                })
                .ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously transports from the current map to given spawn in the given map.
        /// </summary>
        /// <param name="map">The map to transport to.</param>
        /// <param name="spawnIndex">The spawn index on the map to transport to.</param>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     Information about our location and map after we transport.
        /// </returns>
        public async Task TransportAsync(string map, int spawnIndex)
        {
            var source = new TaskCompletionSource<Expectation<NewMapData>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.BankOperation when data.Reason.EqualsI("mounted") => source.TrySetResult(
                            "Transport failed. (character already in bank)"),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, data =>
                {
                    if (data.Map.EqualsI(map))
                        source.TrySetResult(data);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Transport, new { to = map, s = spawnIndex }).ConfigureAwait(false);
            NewMapData newMap = await source.Task.WithNetworkTimeout().ConfigureAwait(false);

            //if we're entering a bank, wait for bank data to populate
            var newData = GameData.Maps[newMap.Map];

            if (newData == null)
                return;

            if (newMap.Map.ContainsI("bank") && newData.Mount)
                await WaitForBankAsync().ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously unequips an item from a slot.
        /// </summary>
        /// <param name="slot">The slot of the item to unequip.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     Information about the item that was unequiped within the inventory.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to unequip item {itemNameOrSlot}. ({reason})</exception>
        public async Task<InventoryIndexer> UnequipAsync(Slot slot)
        {
            var item = Character.Slots[slot];

            if (item == null)
                throw new InvalidOperationException($"Failed to unequip item {slot}. (no item in slot)");

            if (Character.EmptySlots == 0)
                throw new InvalidOperationException($"Failed to unequip item {item.Name}. (no space)");

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);
            var previousInventory = Character.Inventory.AsIndexed();

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    var slotItem = data.Slots[slot];

                    if (slotItem == null)
                    {
                        var inventoryItem = Character.Inventory.AsIndexed()
                            .Except(previousInventory)
                            .FirstOrDefault(indexed => indexed.Item.Name.EqualsI(item.Name) && (indexed.Item.Level == item.Level));

                        if (inventoryItem != null)
                            source.TrySetResult(inventoryItem);
                    }

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Unequip, new { slot }).ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        /// <summary>
        ///     Attempts to upgrade an item.
        /// </summary>
        /// <param name="inventorySlot">The inventory index of the item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if the upgrade succeeded, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to upgrade. ({reason})</exception>
        public async Task<bool> UpgradeAsync(int inventorySlot, int scrollIndex, int? offeringIndex = null)
        {
            var item = Character.Inventory[inventorySlot];
            var source = new TaskCompletionSource<Expectation<bool?>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.UpgradeNoItem             => source.TrySetResult("Failed to compound. (items not the same)"),
                        GameResponseType.UpgradeInProgress         => source.TrySetResult("Failed to upgrade. (already upgrading)"),
                        GameResponseType.UpgradeIncompatibleScroll => source.TrySetResult("Failed to upgrade. (wrong scroll)"),
                        GameResponseType.UpgradeNoScroll           => source.TrySetResult("Failed to upgrade. (no scroll)"),
                        GameResponseType.UpgradeMismatch => source.TrySetResult(
                            "Failed to upgrade. (unknown, this seems to be a catch-all)"),
                        GameResponseType.UpgradeCant            => source.TrySetResult("Failed to upgrade. (item not upgradable)"),
                        GameResponseType.UpgradeInvalidOffering => source.TrySetResult("Failed to upgrade. (offering is not an offering)"),
                        GameResponseType.BankRestrictions       => source.TrySetResult("Failed to upgrade. (can't upgrade from bank)"),
                        GameResponseType.ECUGetCloser           => source.TrySetResult("Failed to upgrade. (get closer)"),
                        GameResponseType.UpgradeSuccess         => source.TrySetResult(true),
                        GameResponseType.UpgradeFail            => source.TrySetResult(false),
                        _                                       => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Upgrade, new
                {
                    item_num = inventorySlot, scroll_num = scrollIndex, offering_num = offeringIndex,
                    clevel = item?.Level ?? 0
                })
                .ConfigureAwait(false);

            return await source.Task.WithTimeout(60000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Attempts to have the server calculate the chance for an upgrade to succeed.
        /// </summary>
        /// <param name="inventorySlot">The inventory index of the item.</param>
        /// <param name="scrollIndex">The inventory index of the compound scroll.</param>
        /// <param name="offeringIndex">Optional: the inventory index of a tribute item.</param>
        /// <returns>
        ///     <see cref="ResponseItem" /> <br />
        ///     An object containing details about the item, and it's chance to successully be upgraded.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to upgrade. ({reason})</exception>
        public async Task<ResponseItem> UpgradeChanceAsync(int inventorySlot, int scrollIndex, int? offeringIndex = null)
        {
            var item = Character.Inventory[inventorySlot];
            var source = new TaskCompletionSource<Expectation<ResponseItem>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    var result = data.ResponseType switch
                    {
                        GameResponseType.UpgradeNoItem             => source.TrySetResult("Failed to compound. (no item at index)"),
                        GameResponseType.UpgradeInProgress         => source.TrySetResult("Failed to upgrade. (already upgrading)"),
                        GameResponseType.UpgradeIncompatibleScroll => source.TrySetResult("Failed to upgrade. (wrong scroll)"),
                        GameResponseType.UpgradeNoScroll           => source.TrySetResult("Failed to upgrade. (no scroll)"),
                        GameResponseType.UpgradeMismatch => source.TrySetResult(
                            "Failed to upgrade. (unknown, this seems to be a catch-all)"),
                        GameResponseType.UpgradeCant            => source.TrySetResult("Failed to upgrade. (item not upgradable)"),
                        GameResponseType.UpgradeInvalidOffering => source.TrySetResult("Failed to upgrade. (offering is not an offering)"),
                        GameResponseType.BankRestrictions       => source.TrySetResult("Failed to upgrade. (can't upgrade from bank)"),
                        GameResponseType.ECUGetCloser           => source.TrySetResult("Failed to upgrade. (get closer)"),
                        GameResponseType.UpgradeChance when data.Item?.Name.EqualsI(item?.Name) ?? false => source.TrySetResult(
                            data.Item with
                            {
                                Grace = data.Grace,
                                Chance = data.Chance
                            }),
                        _ => false
                    };

                    return Task.FromResult(result);
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Upgrade, new
                {
                    item_num = inventorySlot,
                    scroll_num = scrollIndex,
                    offering_num = offeringIndex,
                    clevel = item?.Level ?? 0
                })
                .ConfigureAwait(false);

            return await source.Task.WithTimeout(60000).ConfigureAwait(false);
        }

        /// <summary>
        ///     Asynchronously uses an HP or MP potion from the inventory. <br />
        ///     To check the cooldown of potions/regen, check the cooldown of the skill "use_hp" or "use_mp".
        /// </summary>
        /// <param name="inventorySlot">The inventory index of the potion to be used.</param>
        /// <exception cref="InvalidOperationException">Failed to use pot {slotOrName}. ({reason})</exception>
        public async Task UsePotAsync(int inventorySlot)
        {
            var item = Character.Inventory[inventorySlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to use pot {inventorySlot}. (no item)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    if (data.Id.EqualsI(Character.Name) && data.Message.EqualsI("not ready"))
                        source.TrySetResult($"Failed to use pot {item.Name}. (not ready)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var evalCallback = Socket.On<EvalData>(ALSocketMessageType.Eval, data =>
                {
                    if (!string.IsNullOrEmpty(data.Code) && RegexCache.POT_TIMEOUT.IsMatch(data.Code))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Equip, new { num = inventorySlot }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously regens a small amount of hp. Has a shared CD with potions with a 2x multiplier.
        /// </summary>
        /// <exception cref="InvalidOperationException">Failed to use regen_hp. ({readon})</exception>
        public async Task UseRegenHPAsync()
        {
            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    if (data.Id.EqualsI(Character.Name) && data.Message.EqualsI("not ready"))
                        source.TrySetResult("Failed to use regen_hp. (not ready)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var evalCallback = Socket.On<EvalData>(ALSocketMessageType.Eval, data =>
                {
                    if (!string.IsNullOrEmpty(data.Code) && RegexCache.POT_TIMEOUT.IsMatch(data.Code))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Use, new { item = "hp" }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously regens a small amount of mp. Has a shared CD with potions with a 2x multiplier.
        /// </summary>
        /// <exception cref="InvalidOperationException">Failed to use regen_mp. ({readon})</exception>
        public async Task UseRegenMPAsync()
        {
            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(ALSocketMessageType.DisappearingText, data =>
                {
                    if (data.Id.EqualsI(Character.Name) && data.Message.EqualsI("not ready"))
                        source.TrySetResult("Failed to use regen_mp. (not ready)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var evalCallback = Socket.On<EvalData>(ALSocketMessageType.Eval, data =>
                {
                    if (!string.IsNullOrEmpty(data.Code) && RegexCache.POT_TIMEOUT.IsMatch(data.Code))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Use, new { item = "mp" }).ConfigureAwait(false);

            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously uses the town ability to go to spawn index 0 on the current map.
        /// </summary>
        /// <param name="token">A token used to cancel this action.</param>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     The data for the map after this action has completed or been canceled.
        /// </returns>
        public async Task UseTownAsync(CancellationToken? token = null)
        {
            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);

            var warpBegin = false;

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    // ReSharper disable once ConvertIfStatementToSwitchStatement
                    if (!warpBegin && (data.Channeling != null) && data.Channeling.ContainsKey("town"))
                        warpBegin = true;
                    else if (warpBegin && (data.Channeling?.ContainsKey("town") != true))
                        source.TrySetResult("Failed to town. (canceled)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap, data =>
                {
                    if (warpBegin && (data.Effect == DisappearEffect.Town))
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    if (data.ResponseType == GameResponseType.TransportFailed)
                        source.TrySetResult("Failed to town. (failed)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.ReturnToTown).ConfigureAwait(false);

            token?.Register(() =>
            {
                _ = Socket.EmitAsync(ALSocketEmitType.Stop, new { action = "town" });
                Logger.Info("Town recall canceled");
                source.TrySetResult(Expectation.Success);
            });

            var expectation = await source.Task.WithTimeout(5000).ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously withdraws gold from the bank.
        /// </summary>
        /// <param name="amount">The amount of gold to withdraw</param>
        /// <exception cref="InvalidOperationException">Failed to withdraw {amount} gold. ({reason})</exception>
        public async Task WithdrawGoldAsync(long amount)
        {
            if (Character.Bank == null)
                throw new InvalidOperationException($"Failed to withdraw {amount} gold. (not in bank)");

            var shouldChange = (amount > 0) && (Bank!.Gold > 0);

            if (!shouldChange || (amount > Bank!.Gold))
                throw new InvalidOperationException($"Failed to withdraw {amount} gold. (invalid amount)");

            var source = new TaskCompletionSource<Expectation>(TaskCreationOptions.RunContinuationsAsynchronously);
            var previousGold = Character.Gold;

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (data.Bank == null)
                        source.TrySetResult($"Failed to withdraw {amount} gold. (not in bank)");

                    var didChange = !previousGold.NearlyEquals(data.Gold, CORE_CONSTANTS.EPSILON);

                    if (shouldChange && didChange)
                        source.TrySetResult(Expectation.Success);

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Bank, new { amount, operation = "withdraw" }).ConfigureAwait(false);
            var expectation = await source.Task.WithNetworkTimeout().ConfigureAwait(false);
            expectation.ThrowIfUnsuccessful();
        }

        /// <summary>
        ///     Asynchronously withdraws an item from the bank.
        /// </summary>
        /// <param name="bankPack">The bankPack to withdraw from.</param>
        /// <param name="bankSlot">The slot within the bankPack to withdraw from.</param>
        /// <param name="inventorySlot">The slot in the inventory to place the item. -1 for first available.</param>
        /// <returns>
        ///     <see cref="InventoryIndexer" /> <br />
        ///     Information about the withdrawn item in the inventory.
        /// </returns>
        /// <exception cref="InvalidOperationException">Failed to withdraw item {item}. ({reason})</exception>
        public async Task<InventoryIndexer> WithdrawItemAsync(BankPack bankPack, int bankSlot, int inventorySlot = -1)
        {
            if (Character.Bank == null)
                throw new InvalidOperationException($"Failed to withdraw item {bankPack}:{bankSlot}. (not in bank)");

            var availableBanks = Utility.GetAvailableBankPacks(Character.Map);

            if (!availableBanks.Contains(bankPack) || !Bank!.TryGetValue(bankPack, out var bankedItems))
                throw new InvalidOperationException($"Failed to withdraw item {bankPack}:{bankSlot}. (wrong bank)");

            var item = bankedItems[bankSlot];

            if (item == null)
                throw new InvalidOperationException($"Failed to withdraw item {bankPack}:{bankSlot}. (no item)");

            var source = new TaskCompletionSource<Expectation<InventoryIndexer>>(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
                {
                    if (data.ResponseType == GameResponseType.Invalid)
                        source.TrySetResult($"Failed to withdraw item {item.Name}. (invalid)");

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if (data.Bank == null)
                        source.TrySetResult($"Failed to withdraw item {bankPack}:{bankSlot}. (not in bank)");

                    var inventoryItem = data.Inventory[inventorySlot];

                    if (inventoryItem != null)
                        source.TrySetResult(new InventoryIndexer { Index = inventorySlot, Item = inventoryItem });

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            await Socket.EmitAsync(ALSocketEmitType.Bank,
                    new { operation = "swap", inv = inventorySlot, str = bankSlot, pack = bankPack.ToString().ToLower() })
                .ConfigureAwait(false);

            return await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }
        #endregion

        #region Events
        protected void AttachListeners()
        {
            if (Socket == null)
                throw new NullReferenceException(nameof(Socket));

            Socket.On<StartData>(ALSocketMessageType.Start, OnStartAsync);
            Socket.On<ChestOpenedData>(ALSocketMessageType.ChestOpened, OnChestOpened);
            Socket.On<CharacterData>(ALSocketMessageType.Character, OnCharacterAsync);
            Socket.On<CorrectionData>(ALSocketMessageType.Correction, OnCorrectionAsync);
            Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, OnGameResponseAsync);
            Socket.On<EntitiesData>(ALSocketMessageType.Entities, OnEntitiesAsync);
            Socket.On<AchievementProgressData>(ALSocketMessageType.AchievementProgress, OnAchievementProgressAsync);
            Socket.On<DropData>(ALSocketMessageType.Drop, OnDropAsync);
            Socket.On<EvalData>(ALSocketMessageType.Eval, OnEvalAsync);
            Socket.On<GameMessageData>(ALSocketMessageType.GameError, OnGameErrorAsync);
            Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, OnPartyUpdateAsync);
            Socket.On<InviteData>(ALSocketMessageType.Invite, OnPartyInvited);
            Socket.On<QueuedActionData>(ALSocketMessageType.QueuedActionData, OnQueuedActionAsync);
            Socket.On<QueuedActionResultData>(ALSocketMessageType.QueuedActionResult, OnQueuedActionResult);
            Socket.On<WelcomeData>(ALSocketMessageType.Welcome, OnWelcomeAsync);
            Socket.On<ActionData>(ALSocketMessageType.Action, OnActionAsync);
            Socket.On<DeathData>(ALSocketMessageType.Death, OnDeathAsync);
            Socket.On<DisappearData>(ALSocketMessageType.Disappear, OnDisappearAsync);
            Socket.On<HitData>(ALSocketMessageType.Hit, OnHitAsync);
            Socket.On<NewMapData>(ALSocketMessageType.NewMap, OnNewMapAsync);
            Socket.On<EventAndBossData>(ALSocketMessageType.ServerInfo, OnServerInfo);
        }

        protected async Task<bool> OnChestOpened(ChestOpenedData data)
        {
            await Chests.RemoveAsync(data.Id).ConfigureAwait(false);

            return false;
        }

        protected Task<bool> OnPartyInvited(InviteData data)
        {
            OnPartyInvite?.Invoke(this, data);

            return TaskCache.FALSE;
        }

        protected async Task<bool> OnAchievementProgressAsync(AchievementProgressData data)
        {
            await AchievementProgress.AddOrUpdateAsync(data.Name, data).ConfigureAwait(false);

            return false;
        }

        protected async Task<bool> OnActionAsync(ActionData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId))
                await Projectiles.AddOrUpdateAsync(data.ProjectileId, data).ConfigureAwait(false);

            return false;
        }

        protected async Task<bool> OnCharacterAsync(CharacterData data)
        {
            data.CompensateOnce(PingManager.Offset);
            ShallowMerge<Character>.Merge(data, Character);

            //keep a copy of the bank data
            if (data.Bank != null)
                Bank = data.Bank;

            if (data.ExtraEvents.Count > 0)
                foreach (var jArr in data.ExtraEvents)
                {
                    var raw = jArr.ToString();
                    await Socket.HandleEventAsync(raw).ConfigureAwait(false);
                }

            return false;
        }

        protected Task<bool> OnCorrectionAsync(CorrectionData data)
        {
            Character.CorrectAndCompensate(data, PingManager.Offset);

            return TaskCache.FALSE;
        }

        protected async Task<bool> OnDeathAsync(DeathData data)
        {
            await DestroyEntity(data.Id).ConfigureAwait(false);

            return false;
        }

        protected async Task<bool> OnDisappearAsync(DisappearData data)
        {
            await DestroyEntity(data.Id).ConfigureAwait(false);

            return false;
        }

        protected async Task<bool> OnDropAsync(DropData data)
        {
            await Chests.AddOrUpdateAsync(data.Id, data).ConfigureAwait(false);

            return false;
        }

        protected async Task<bool> OnEntitiesAsync(EntitiesData data)
        {
            await UpdateMonsters(data.Monsters, data.In, data.Map, data.UpdateType).ConfigureAwait(false);
            await UpdatePlayers(data.Players, data.In, data.Map, data.UpdateType).ConfigureAwait(false);

            Character.UpdateMap(data.In, data.Map);

            return false;
        }

        //TODO: figure out how to handle eval
        protected async Task<bool> OnEvalAsync(EvalData data)
        {
            Match match;

            if (string.IsNullOrEmpty(data.Code))
                return false;

            if ((match = RegexCache.SKILL_TIMEOUT.Match(data.Code)).Success)
            {
                var skillName = match.Groups[1].Value;
                var cooldownStr = match.Groups[2].Value;

                if (string.IsNullOrEmpty(skillName))
                    throw new InvalidOperationException($"Failed to parse skill cooldown. ({data.Code})");

                if (float.TryParse(cooldownStr, out var cooldownMS))
                    await SetCooldownAsync(skillName, cooldownMS).ConfigureAwait(false);
                else
                    await SetCooldownAsync(skillName).ConfigureAwait(false);
            } else if ((match = RegexCache.POT_TIMEOUT.Match(data.Code)).Success)
            {
                const string? USE_HP = "use_hp";
                const string? USE_MP = "use_mp";
                var cooldownStr = match.Groups[1].Value;

                if (!float.TryParse(cooldownStr, out var cooldownMS))
                    throw new InvalidOperationException($"Failed to parse potion cooldown. ({data.Code})");

                await SetCooldownAsync(USE_HP, cooldownMS).ConfigureAwait(false);
                await SetCooldownAsync(USE_MP, cooldownMS).ConfigureAwait(false);
            }

            return false;
        }

        protected Task<bool> OnGameErrorAsync(GameMessageData data)
        {
            Logger.Warn($"GAME ERROR: {data.Message}");

            return TaskCache.FALSE;
        }

        protected async Task<bool> OnGameResponseAsync(GameResponseData data)
        {
            if (!data.ContainsData)
                return false;

            // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
            switch (data.ResponseType)
            {
                case GameResponseType.Cooldown:
                {
                    await SetCooldownAsync(data.SkillName ?? data.Place!, data.CooldownMS).ConfigureAwait(false);

                    break;
                }
                case GameResponseType.ConditionExpired:
                {
                    if (EnumHelper.TryParse(data.Name, out Condition conditionName))
                        await Character.Conditions.RemoveAsync(conditionName).ConfigureAwait(false);

                    break;
                }

                case GameResponseType.SkillSuccess:
                {
                    if (await IsOffCooldown(data.SkillName ?? data.Name!).ConfigureAwait(false))
                        await SetCooldownAsync(data.SkillName ?? data.Name!).ConfigureAwait(false);

                    break;
                }
            }

            return false;
        }

        protected async Task<bool> OnHitAsync(HitData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId)
                && await Projectiles.TryGetValueAsync(data.ProjectileId, out var projectileTask).ConfigureAwait(false))
            {
                var projectile = await projectileTask.ConfigureAwait(false);
                await Projectiles.RemoveAsync(data.ProjectileId).ConfigureAwait(false);

                if ((data.Reflect != 0) && !string.IsNullOrEmpty(projectile?.ProjectileId))
                {
                    var newProjectile = projectile with
                    {
                        Damage = data.Reflect, Target = data.HitId, X = Character.X, Y = Character.Y
                    };

                    await Projectiles.AddOrUpdateAsync(newProjectile.ProjectileId, newProjectile).ConfigureAwait(false);
                }
            }

            if (data.Kill)
                await DestroyEntity(data.Id).ConfigureAwait(false);
            else if (data.Damage != 0)
            {
                var entity = await GetEntity(data.Id).ConfigureAwait(false);
                entity?.Mutate(new Mutation(ALAttribute.Hp, -data.Damage));
            }

            if (data.Reflect != 0)
            {
                var sourceEntity = await GetEntity(data.Source).ConfigureAwait(false);
                sourceEntity?.Mutate(new Mutation(ALAttribute.Hp, -data.Reflect));
            }

            return false;
        }

        protected async Task<bool> OnNewMapAsync(NewMapData data)
        {
            if (data.Map.EqualsI("jail"))
            {
                var standingLocation = Character.ToLocation();
                var standingOnWall = PathFinder.IsWall(standingLocation);
                var goingLocation = new Location(Character.Map, Character.GoingX, Character.GoingY);
                var validPath = PathFinder.CanMove(standingLocation, goingLocation);

                Logger.Error(
                    $"Sent to jail from {Character.ToLocation()} (IsWall: {standingOnWall}), moving to {goingLocation} (Valid: {validPath})");
            }

            await Projectiles.ClearAsync().ConfigureAwait(false);
            Character.UpdateLocation(data);

            await OnEntitiesAsync(data.Entities).ConfigureAwait(false);

            return false;
        }

        protected Task<bool> OnPartyUpdateAsync(PartyUpdateData data)
        {
            Party = data;

            return TaskCache.FALSE;
        }

        protected Task<bool> OnQueuedActionAsync(QueuedActionData data)
        {
            if (data.QueuedActionInfo != null)
                Character.Update(data.QueuedActionInfo);

            return TaskCache.FALSE;
        }

        protected Task<bool> OnServerInfo(EventAndBossData data)
        {
            var bossInfoDic = (Dictionary<string, BossInfo>)data.BossInfo;
            EventsAndBosses = data;

            foreach ((var name, var bossInfo) in bossInfoDic)
                if (bossInfo.HP == 0)
                {
                    var mData = GameData.Monsters[name];

                    if (mData == null)
                        continue;

                    bossInfo.Mutate(new Mutation(ALAttribute.Hp, mData.HP));
                }

            return TaskCache.FALSE;
        }

        protected async Task<bool> OnStartAsync(StartData data)
        {
            BaseGold = data.BaseGold;
            EventsAndBosses = data.EventAndBossInfo;

            await OnCharacterAsync(data).ConfigureAwait(false);
            await OnEntitiesAsync(data.Entities).ConfigureAwait(false);

            return false;
        }

        protected Task<bool> OnQueuedActionResult(QueuedActionResultData data)
        {
            if (Character.QueuedActions != null)
                // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                switch (data.QueuedActionType)
                {
                    case QueuedActionType.Compound:
                        Character.Update(Character.QueuedActions with { Compound = null });

                        break;
                    case QueuedActionType.Upgrade:
                        Character.Update(Character.QueuedActions with { Upgrade = null });

                        break;
                    case QueuedActionType.Exchange:
                        Character.Update(Character.QueuedActions with { Exchange = null });

                        break;
                    default:
                        throw new ArgumentOutOfRangeException($"Unknown upgrade type {(int)data.QueuedActionType}.");
                }

            return TaskCache.FALSE;
        }

        protected async Task<bool> OnWelcomeAsync(WelcomeData data)
        {
            if ((Server.Identifier != data.Identifier) || (Server.Region != data.Region))
                throw new Exception(
                    $"Logged into wrong server. Expected: {Server.Region} {Server.Identifier}  Current: {data.Region} {data.Identifier}");

            await Socket.EmitAsync(ALSocketEmitType.Loaded, new
                {
                    height = 1080,
                    width = 1920,
                    scale = 2,
                    success = 1
                })
                .ConfigureAwait(false);

            if (data.Character != null)
                await OnCharacterAsync(data.Character).ConfigureAwait(false);

            return false;
        }
        #endregion

        #region Helpers
        protected async ValueTask<bool> DestroyEntity(string id)
        {
            var result = await Monsters.RemoveAsync(id).ConfigureAwait(false) || await Players.RemoveAsync(id).ConfigureAwait(false);

            var bossInfoDic = (Dictionary<string, BossInfo>)EventsAndBosses.BossInfo;
            bossInfoDic.Remove(id);

            return result;
        }

        protected async ValueTask<EntityBase?> GetEntity(string id) =>
            await Players.TryGetValueAsync(id, out var playerTask).ConfigureAwait(false)   ? await playerTask.ConfigureAwait(false) :
            await Monsters.TryGetValueAsync(id, out var monsterTask).ConfigureAwait(false) ? await monsterTask.ConfigureAwait(false) : null;

        protected (BankPack BankPack, int BankSlot)? FindOptimalBankIndex(
            IIndexer<IInventoryItem> indexedInventoryItem,
            BankPack? bankPack = null,
            int? bankSlot = null)
        {
            //if both indexes are specified, just check that they are valid.
            if (bankPack.HasValue && bankSlot.HasValue)
                if (!Bank!.TryGetValue(bankPack.Value, out var bankedItems) || (bankedItems[bankSlot.Value] != null))
                    return null;
                else
                    return (bankPack.Value, bankSlot.Value);

            var item = indexedInventoryItem.Item;
            var itemData = item.GetData();
            var stackSize = itemData?.StackSize ?? 1;
            //an enumerable of acceptable bankpacks or the bankPack the user wants to use
            var availableBanks = bankPack.HasValue ? new[] { bankPack.Value } : Utility.GetAvailableBankPacks(Character.Map);
            (BankPack, int)? firstEmptySlot = null;

            foreach (var bankPackIndex in availableBanks)
            {
                //check if they have access to the bankPack
                if (!Bank!.TryGetValue(bankPackIndex, out var bankItems))
                    continue;

                //for each item in this bank pack
                var itemSlotIndex = 0;

                foreach (var bankedItem in bankItems)
                {
                    //if the slot is empty
                    if (bankedItem == null)
                    {
                        //if this item is not stackable, this is the first empty slot to place the item in so just break
                        //if this item IS stackable, continue looking for a slot we can stack the item into
                        if (stackSize == 1)
                            return (bankPackIndex, itemSlotIndex);

                        //if this is the first empty slot we've come across, save it for later
                        //if the item is stackable and we arent able to find a stackable index we will use this
                        firstEmptySlot ??= (bankPackIndex, itemSlotIndex);
                    }
                    //check if the item can stack onto this banked item
                    else if ((stackSize > 1) && item.Name.EqualsI(bankedItem.Name) && (item.Quantity + bankedItem.Quantity <= stackSize))
                        //-1 allows the item to automatically stack
                        return (bankPackIndex, -1);

                    itemSlotIndex++;
                }
            }

            return firstEmptySlot;
        }

        public static async Task InitializeAsync()
        {
            var tasks = new List<Task>
            {
                Task.Run(() => RuntimeHelpers.RunClassConstructor(typeof(RegexCache).TypeHandle)),
                Task.Run(() => RuntimeHelpers.RunClassConstructor(typeof(TaskCache).TypeHandle)),
                Task.Run(async () =>
                {
                    var jData = await ALAPIClient.GetGameDataAsync().ConfigureAwait(false);
                    GameData.Populate(jData);
                })
            };

            await Task.WhenAll(tasks).ConfigureAwait(false);
            await PathFinder.InitializeAsync().ConfigureAwait(false);
        }

        protected async ValueTask SetCooldownAsync(string skillName, float? cooldownMS = null)
        {
            var cooldownMultiplier = 1f;

            var data = GameData.Skills[skillName];

            if (data == null)
                return;

            if (!string.IsNullOrEmpty(data.SharedCooldown))
            {
                skillName = data.SharedCooldown;
                cooldownMultiplier = data.CooldownMultiplier ?? 1f;
                data = GameData.Skills[skillName]!;
            }

            if ((data.CooldownMS > 0) || skillName.EqualsI("attack"))
            {
                if (skillName.EqualsI("attack"))
                    cooldownMS ??= 1000f / Character.Frequency;
                else
                    cooldownMS ??= data.CooldownMS;

                var cooldownInfo = new CooldownInfo(cooldownMS.Value * cooldownMultiplier);
                cooldownInfo.CompensateOnce(PingManager.Offset);

                await Cooldowns.AddOrUpdateAsync(skillName, cooldownInfo).ConfigureAwait(false);
            }
        }

        protected ValueTask UpdateMonsters(IReadOnlyList<Monster> monsters, string @in, string map, EntitiesUpdateType updateType)
        {
            if (updateType == EntitiesUpdateType.All)
                return Monsters.AssertAsync(dic =>
                {
                    //remove extras
                    foreach (var monsterId in dic.Keys.Except(monsters.Select(monster => monster.Id)))
                        dic.Remove(monsterId);

                    //merge existing, add new
                    foreach (var monster in monsters)
                    {
                        monster.UpdateMap(@in, map);
                        monster.CompensateOnce(PingManager.Offset);

                        if (dic.TryGetValue(monster.Id, out var existing))
                            ShallowMerge<Monster>.Merge(monster, existing);
                        else
                        {
                            monster.SetBoundingBase(monster.GetData().BoundingBase);
                            dic.Add(monster.Id, monster);
                        }
                    }
                });

            return Monsters.AssertAsync(dic =>
            {
                //update positions
                foreach (var monster in monsters)
                {
                    monster.UpdateMap(@in, map);
                    monster.CompensateOnce(PingManager.Offset);

                    if (dic.TryGetValue(monster.Id, out var monsterX))
                        monsterX.Update(monster);
                    else
                    {
                        monster.SetBoundingBase(monster.GetData().BoundingBase);
                        dic.Add(monster.Id, monster);
                    }
                }
            });
        }

        protected ValueTask UpdatePlayers(IReadOnlyCollection<Player> players, string @in, string map, EntitiesUpdateType updateType)
        {
            if (updateType == EntitiesUpdateType.All)
                return Players.AssertAsync(dic =>
                {
                    //remove extras
                    foreach (var playerId in dic.Keys.Except(players.Select(player => player.Id)))
                        dic.Remove(playerId);

                    //merge existing, add new
                    foreach (var player in players)
                    {
                        player.UpdateMap(@in, map);
                        player.CompensateOnce(PingManager.Offset);

                        if (player.Equals(Character))
                            Character.UpdateLocation(player);
                        else if (dic.TryGetValue(player.Id, out var existing))
                            ShallowMerge<Player>.Merge(player, existing);
                        else
                        {
                            player.SetBoundingBase(PATHFINDING_CONSTANTS.DEFAULT_BOUNDING_BASE);
                            dic.Add(player.Id, player);
                        }
                    }
                });

            return Players.AssertAsync(dic =>
            {
                foreach (var player in players)
                {
                    player.UpdateMap(@in, map);
                    player.CompensateOnce(PingManager.Offset);

                    if (player.Equals(Character))
                        Character.UpdateLocation(player);
                    else if (dic.TryGetValue(player.Id, out var existing))
                        existing.UpdatePosition(player);
                    else
                        dic.Add(player.Id, player);
                }
            });
        }

        protected async Task WaitForBankAsync()
        {
            //check if bank is already populated
            if (Bank != null)
                return;

            //if not, set up a callback to expect bank data
            var source = new TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously);

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
                {
                    if ((data.Bank != null) || (Bank != null))
                        source.TrySetResult();

                    return TaskCache.FALSE;
                })
                .ConfigureAwait(false);

            //check for bank data again (it could have been set while executing the previous statement
            if (Bank != null)
                return;

            //wait for it to be populated
            await source.Task.WithNetworkTimeout().ConfigureAwait(false);
        }

        protected async void OnDisconnected(object? sender, string message)
        {
            await PingManager.StopAsync().ConfigureAwait(false);
            await PositionManager.StopAsync().ConfigureAwait(false);

            await ReconnectAsync().ConfigureAwait(false);
        }
        #endregion
    }
}