using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using AL.APIClient;
using AL.APIClient.Definitions;
using AL.APIClient.Extensions;
using AL.APIClient.Model;
using AL.Client.Extensions;
using AL.Client.Helpers;
using AL.Client.Managers;
using AL.Client.Model;
using AL.Core.Abstractions;
using AL.Core.Definitions;
using AL.Core.Extensions;
using AL.Core.Helpers;
using AL.Core.Model;
using AL.Data;
using AL.SocketClient;
using AL.SocketClient.Definitions;
using AL.SocketClient.Model;
using AL.SocketClient.SocketModel;
using Chaos.Core.Collections.Synchronized.Awaitable;
using Chaos.Core.Extensions;
using Character = AL.SocketClient.Model.Character;
using Condition = AL.Core.Definitions.Condition;
using CONSTANTS = AL.Client.Definitions.CONSTANTS;

// ReSharper disable PrivateFieldCanBeConvertedToLocalVariable

namespace AL.Client
{
    /// <summary>
    ///     Provides the ability to interact with the Adventure.Land socket server.
    /// </summary>
    /// <seealso cref="NamedLoggerBase" />
    /// <seealso cref="IAsyncDisposable" />
    public class ALClient : NamedLoggerBase, IAsyncDisposable
    {
        private static readonly SemaphoreSlim ConnectSync = new(1, 1);
        private readonly PingManager PingManager;
        private readonly PositionManager PositionManager;
        private readonly SemaphoreSlim Sync = new(1, 1);

        /// <summary>
        ///     This will be populated and persist after the first time this character enters the bank.
        /// </summary>
        public BankInfo? Bank { get; private set; }

        /// <summary>
        ///     A collection of values indicating base gold rewards for killing a monster on a specific map. <br />
        ///     These values are dynamically generated by the server, and different based on class, level, and other factors.
        ///     <br />
        ///     { MonsterName : { MapName: GoldValue } }
        /// </summary>
        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, int>> BaseGold { get; private set; }

        /// <summary>
        ///     This will be populated upon connecting. The character this client is for.
        /// </summary>
        public Character Character { get; private set; }

        /// <summary>
        ///     This will be populated upon connecting. The bosses and events currently active on this <see cref="Server" />.
        /// </summary>
        public EventAndBossInfo EventsAndBosses { get; private set; }

        /// <summary>
        ///     The <see cref="Character" />'s unique identifier, as fetched via the <see cref="API" />.
        /// </summary>
        public string? Identifier { get; private set; }

        /// <summary>
        ///     Contains information about the party.
        /// </summary>
        public PartyUpdateData Party { get; private set; } = new();

        /// <summary>
        ///     The will be populated while connecting. Contains information from the <see cref="API" /> about the server we're
        ///     connecting to.
        /// </summary>
        public Server Server { get; private set; }

        /// <summary>
        ///     Our connection to the Adventure.Land socket server.
        /// </summary>
        public ALSocketClient Socket { get; init; }

        /// <summary>
        ///     The character's progress towards ongoing achievements.
        /// </summary>
        public AwaitableDictionary<string, AchievementProgressData> AchievementProgress { get; }

        /// <summary>
        ///     Our connection to the Adventure.Land API. Also contains information about the currently logged in user.
        /// </summary>
        public ALAPIClient API { get; }

        /// <summary>
        ///     When a chest drops or is opened, it will be populated or removed from this collection.
        /// </summary>
        public AwaitableDictionary<string, DropData> Chests { get; }

        /// <summary>
        ///     When a skill is used and the server sends back a cooldown, it will be populated here.
        /// </summary>
        public AwaitableDictionary<string, CooldownInfo> Cooldowns { get; }

        /// <summary>
        ///     A collection of the monsters we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, Monster> Monsters { get; }

        /// <summary>
        ///     The name of the character this client is for.
        /// </summary>
        public override string Name { get; }

        /// <summary>
        ///     A collection of the players we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, Player> Players { get; }

        /// <summary>
        ///     A collection of projectiles we are keeping track of.
        /// </summary>
        public AwaitableDictionary<string, ActionData> Projectiles { get; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ALClient" /> class.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="apiClient"></param>
        /// <exception cref="ArgumentNullException">name</exception>
        /// <exception cref="ArgumentNullException">apiClient</exception>
        public ALClient(string name, ALAPIClient apiClient)
            : base(name)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentNullException(nameof(name));

            Name = name;
            AchievementProgress = new AwaitableDictionary<string, AchievementProgressData>();
            API = apiClient ?? throw new ArgumentNullException(nameof(apiClient));
            Monsters = new AwaitableDictionary<string, Monster>();
            Players = new AwaitableDictionary<string, Player>();
            Projectiles = new AwaitableDictionary<string, ActionData>();
            BaseGold = new Dictionary<string, IReadOnlyDictionary<string, int>>();
            Cooldowns = new AwaitableDictionary<string, CooldownInfo>(StringComparer.OrdinalIgnoreCase);
            EventsAndBosses = new EventAndBossInfo();
            Chests = new AwaitableDictionary<string, DropData>();
            Socket = new ALSocketClient(name);
            Character = null!;
            Server = null!;

            PingManager = new PingManager(this);
            PositionManager = new PositionManager(this);
        }

        /// <summary>
        ///     Determines if you are able to buy an item by checking inventory space, computer/distance, price, and other common
        ///     factors.
        /// </summary>
        /// <param name="itemName">The name of the item to check.</param>
        /// <param name="fromPonty">Whether or not you're trying to buy it from Ponty.</param>
        /// <returns>
        ///     <see cref="bool" /> <br />
        ///     <c>true</c> if you should be able to buy this item, otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        public bool CanBuy(string itemName, bool fromPonty = false)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (Character.EmptySlots == 0)
                return false;

            var data = GameData.Items[itemName];

            if (data == null)
                return false;

            var price = data.Gold;

            if (fromPonty)
                price *= CONSTANTS.PONTY_MARKUP;

            if (price > Character.Gold)
                return false;

            //TODO: start here
            var hasComputer = Character.Inventory.ContainsItem("computer");


            return false;
        }

        public async ValueTask DisposeAsync()
        {
            GC.SuppressFinalize(this);
            await DisconnectAsync();
        }

        #region Connection stuff

        /// <summary>
        ///     Asynchronously connects to an Adventure.Land socket server.
        /// </summary>
        /// <param name="region">The region to connect to.</param>
        /// <param name="identifier">The identifier within the region to connect to.</param>
        /// <exception cref="InvalidOperationException">There is already an open socket in use. Try disposing it and reconnecting.</exception>
        public async Task ConnectAsync(ServerRegion region, ServerId identifier)
        {
            if (Socket.Open)
                throw new InvalidOperationException(
                    "There is already an open socket in use. Try disposing it and reconnecting.");

            await FetchCharacterAndServerAsync(region, identifier);

            await Sync.WaitAsync();

            try
            {
                AttachListeners();

                var source = new TaskCompletionSource<Expectation<WelcomeData>>();

                await using var gameErrorCallback = Socket.On<GameErrorData>(ALSocketMessageType.GameError,
                    data => Task.FromResult(source.TrySetResult(data.Message)));

                await using var welcomeCallback = Socket.On<WelcomeData>(ALSocketMessageType.Welcome, async data =>
                {
                    await Socket.Emit(ALSocketEmitType.Auth, new
                    {
                        auth = API.AuthUser.AuthKey,
                        character = Identifier,
                        height = 1080,
                        no_graphics = "True",
                        no_html = "1",
                        passphrase = string.Empty,
                        scale = 2,
                        user = API.AuthUser.UserID.ToString(),
                        width = 1920
                    });

                    return source.TrySetResult(data);
                });

                await Socket.ConnectAsync(Server!);

                var result = await source.Task.WithTimeout(5000);
                result.ThrowIfUnsuccessful();

                PositionManager.Start(30);
                PingManager.Start(1 / 4f);
            } finally
            {
                Sync.Release();
            }
        }

        /// <summary>
        ///     This is just a shorthand for creating an <see cref="ALClient" /> and calling <see cref="ConnectAsync" />.
        /// </summary>
        /// <param name="characterName">The name of the character to log in as.</param>
        /// <param name="region">The region to log into.</param>
        /// <param name="identifier">The identifier suffic for the region.</param>
        /// <param name="apiClient">An <see cref="ALAPIClient" /> with your authorization credentials.</param>
        /// <returns>
        ///     <see cref="ALClient" />
        /// </returns>
        /// <exception cref="ArgumentNullException">characterName</exception>
        /// <exception cref="ArgumentNullException">apiClient</exception>
        public static async Task<ALClient> StartCharacterAsync(
            string characterName,
            ServerRegion region,
            ServerId identifier,
            ALAPIClient apiClient)
        {
            if (string.IsNullOrEmpty(characterName))
                throw new ArgumentNullException(nameof(characterName));

            if (apiClient == null)
                throw new ArgumentNullException(nameof(apiClient));

            var client = new ALClient(characterName, apiClient);
            await client.ConnectAsync(region, identifier);

            return client;
        }

        /// <summary>
        ///     <inheritdoc cref="ALSocketClient.DisconnectAsync" />
        /// </summary>
        public async Task DisconnectAsync()
        {
            await Sync.WaitAsync();

            try
            {
                Warn("Disconnecting");
                await Socket.DisconnectAsync();
            } finally
            {
                Sync.Release();
            }
        }

        private async Task FetchCharacterAndServerAsync(ServerRegion region, ServerId identifier)
        {
            await ConnectSync.WaitAsync();

            try
            {
                //if servers/characters not populated, populate them
                if ((API.Servers == null)
                    || (API.Servers.Count == 0)
                    || (API.Characters == null)
                    || (API.Characters.Count == 0))
                    await API.UpdateServersAndCharactersAsync();
            } finally
            {
                ConnectSync.Release();
            }

            //find server and character
            var charInfo = API.Characters!.FirstOrDefault(character => character.Name.EqualsI(Name));
            var serverInfo =
                API.Servers!.FirstOrDefault(server => (server.Region == region) && (server.Identifier == identifier));

            if (charInfo == null)
                throw new InvalidOperationException($@"Character ""{Name}"" not found.");

            if (serverInfo == null)
                throw new InvalidOperationException($@"Server {region} {identifier} not found.");

            Server = serverInfo;
            Identifier = charInfo.Id;
        }

        #endregion

        #region Actions

        /// <summary>
        ///     Asynchronously accepts a magiport offer.
        /// </summary>
        /// <param name="from">The name of the character who offered the magiport.</param>
        /// <returns>
        ///     <see cref="NewMapData" /> <br />
        ///     Information about the map you got magiported to.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        public async Task<NewMapData> AcceptMagiportAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<NewMapData>>();

            await using var newMapCallback = Socket.On<NewMapData>(ALSocketMessageType.NewMap,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Magiport, new { name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously accepts a party invite.
        /// </summary>
        /// <param name="from">The name of the character who invited you.</param>
        /// <returns>
        ///     <see cref="PartyUpdateData" /> <br />
        ///     Information about the party state after accepting the invite.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        public async Task<PartyUpdateData> AcceptPartyInviteAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<PartyUpdateData>>();

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
            {
                var result = false;

                if (data.MemberNames.ContainsI(from))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("invitation expired") || data.EqualsI($"{from} is not found"))
                    result = source.TrySetResult(data);
                else if (data.EqualsI("already partying"))
                    if (Party == null)
                        result = source.TrySetResult(data);
                    else
                        result = Party.MemberNames.ContainsI(from)
                            ? source.TrySetResult(Party)
                            : source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Party, new { @event = "accept", name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously accepts a party request.
        /// </summary>
        /// <param name="from">The name of the character who requested the invite.</param>
        /// <returns>
        ///     <see cref="PartyUpdateData" /> <br />
        ///     Information about the party state after accepting the request.
        /// </returns>
        /// <exception cref="ArgumentNullException">from</exception>
        /// <exception cref="InvalidOperationException">{reason}</exception>
        public async Task<PartyUpdateData> AcceptPartyRequestAsync(string from)
        {
            if (string.IsNullOrEmpty(from))
                throw new ArgumentNullException(nameof(from));

            var source = new TaskCompletionSource<Expectation<PartyUpdateData>>();

            await using var partyUpdateCallback = Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, data =>
            {
                var result = false;

                if (data.MemberNames.ContainsI(from))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("request expired") || data.EqualsI($"{from} is not found"))
                    result = source.TrySetResult(data);
                else if (data.EqualsI("already partying"))
                    if (Party == null)
                        result = source.TrySetResult(data);
                    else
                        result = Party.MemberNames.ContainsI(from)
                            ? source.TrySetResult(Party)
                            : source.TrySetResult(data);

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.Party, new { @event = "raccept", name = from });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to attack a target.
        /// </summary>
        /// <param name="targetId">The id of the target to attack.</param>
        /// <returns>
        ///     <see cref="ActionData" /> <br />
        ///     Details about the action taken.
        /// </returns>
        /// <exception cref="ArgumentNullException">targetId</exception>
        /// <exception cref="InvalidOperationException">Attack on {targetId} failed. ({reason})</exception>
        public async Task<ActionData> AttackAsync(string targetId)
        {
            if (string.IsNullOrEmpty(targetId))
                throw new ArgumentNullException(nameof(targetId));

            var source = new TaskCompletionSource<Expectation<ActionData>>();

            await using var deathCallback = Socket.On<DeathData>(ALSocketMessageType.Death,
                data => Task.FromResult(data.Id.EqualsI(targetId)
                                        && source.TrySetResult($"Attack on {targetId} failed. (target died)")));

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.Disabled when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (disabled)"),
                    GameResponseType.AttackFailed when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed."),
                    GameResponseType.TooFar when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (too far: {data.Distance})"),
                    GameResponseType.Cooldown when data.TargetID.EqualsI(targetId) => source.TrySetResult(
                        $"Attack on {targetId} failed. (on cooldown: {data.CooldownMS}"),
                    GameResponseType.NoMP when data.Place == "attack" => source.TrySetResult(
                        $"Attack on {targetId} failed. (not enough mp)"),
                    _ => false
                };

                return Task.FromResult(result);
            });

            await using var actionCallback = Socket.On<ActionData>(ALSocketMessageType.Action, data =>
            {
                var result = false;

                if (data.AttackerId.EqualsI(Character.Id) && data.Target.EqualsI(targetId) && (data.Type == "attack"))
                    result = source.TrySetResult(data);

                return Task.FromResult(result);
            });

            if (!await Monsters.ContainsKeyAsync(targetId) && !await Players.ContainsKeyAsync(targetId))
                throw new InvalidOperationException($"Attack on {targetId} failed. (not found)");

            await Socket.Emit(ALSocketEmitType.Attack, new { id = targetId });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from an NPC.
        /// </summary>
        /// <param name="itemName">The name of the item to buy.</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="SimpleItem" /> <br />
        ///     Basic information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">itemName</exception>
        /// <exception cref="InvalidOperationException">Quantity cannot be below 1.</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {itemName}. ({reason})</exception>
        public async Task<IndexedSimpleItem> BuyAsync(string itemName, int quantity = 1)
        {
            if (string.IsNullOrEmpty(itemName))
                throw new ArgumentNullException(nameof(itemName));

            if (quantity < 1)
                throw new InvalidOperationException("Quantity cannot be below 1.");

            var source = new TaskCompletionSource<Expectation<IndexedSimpleItem>>();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = data.ResponseType switch
                {
                    GameResponseType.BuySuccess => source.TrySetResult(new IndexedSimpleItem
                    {
                        Index = data.SlotNum,
                        Item = new SimpleItem
                        {
                            Name = data.Name!,
                            Quantity = data.Quantity
                        }
                    }),
                    GameResponseType.BuyCantNPC => source.TrySetResult($"Failed to buy {itemName}. (wrong npc)"),
                    GameResponseType.BuyCantSpace => source.TrySetResult(
                        $"Failed to buy {itemName}. (not enough space)"),
                    GameResponseType.BuyCost => source.TrySetResult($"Failed to buy {itemName}. (not enough gold)"),
                    GameResponseType.BuyGetCloser => source.TrySetResult(
                        $"Failed to buy {itemName}. (get closer: {data.Distance})"),
                    _ => false
                };

                return Task.FromResult(result);
            });

            if (GameData.Items[itemName]?.StackSize > 1)
                await Socket.Emit(ALSocketEmitType.Buy, new { name = itemName, quantity });
            else
                await Socket.Emit(ALSocketEmitType.Buy, new { name = itemName });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously attempts to buy an item from a player.
        /// </summary>
        /// <param name="playerName">The name of the player to buy from.</param>
        /// <param name="slot">The slot in the player's stand the item is in.</param>
        /// <param name="itemId">The unique id of the item.</param>
        /// <param name="quantity">The quantity of the item to buy.</param>
        /// <returns>
        ///     <see cref="IndexedInventoryItem" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">playerName</exception>
        /// <exception cref="ArgumentNullException">itemId</exception>
        /// <exception cref="InvalidOperationException">{reason}</exception>
        public async Task<IndexedInventoryItem> BuyFromPlayerAsync(
            string playerName,
            TradeSlot slot,
            string itemId,
            int quantity = 1)
        {
            if (string.IsNullOrEmpty(playerName))
                throw new ArgumentNullException(nameof(playerName));

            if (string.IsNullOrEmpty(itemId))
                throw new ArgumentNullException(nameof(itemId));

            if (quantity < 1)
                throw new InvalidOperationException("Quantity cannot be below 1.");

            var source = new TaskCompletionSource<Expectation<IndexedInventoryItem>>();

            if (!await Players.TryGetValueAsync(playerName, out var playerTask))
                throw new InvalidOperationException($"{playerName} is not near.");

            var player = await playerTask;

            if (!player.Slots.TryGetValue(slot.ToSlot(), out var slotItem))
                throw new InvalidOperationException($"{playerName} does not have an item in {slot}.");

            if (slotItem.Id != itemId)
                throw new InvalidOperationException($"Item in {slot} has different id than specified.");

            var existingItems = Character.Inventory.AsIndexed();
            var existingTotal = Character.Inventory.CountOf(slotItem.Name);

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = false;

                if (data.ResponseType == GameResponseType.TradeGetCloser)
                    result = source.TrySetResult($"Failed to buy {slotItem.Name} from {player.Name}. (get closer)");

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("not enough gold"))
                    result = source.TrySetResult(
                        $"Failed to buy {slotItem.Name} from {player.Name}. (not enough gold)");
                else if (data.EqualsI("you can't buy that many"))
                    result = source.TrySetResult($"Failed to buy {slotItem.Name} from {player.Name}. (wrong quantity)");

                return Task.FromResult(result);
            });

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(
                ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {slotItem.Name} from {player.Name}. (no space)");

                    return Task.FromResult(result);
                });

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
            {
                var result = false;

                var newTotal = data.Inventory.CountOf(slotItem.Name);

                if (newTotal - existingTotal == quantity)
                    result = source.TrySetResult(data.Inventory.AsIndexed().Except(existingItems).First());

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.TradeBuy,
                new { slot, id = playerName, rid = itemId, q = quantity.ToString() });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Attempts to buy an item from Ponty. <br />
        ///     Ponty sells items other players have sold to NPCs, but at a 20% markup.
        /// </summary>
        /// <param name="item">The item to buy.</param>
        /// <returns>
        ///     <see cref="IndexedInventoryItem" /> <br />
        ///     Information about the item that was bought.
        /// </returns>
        /// <exception cref="ArgumentNullException">item</exception>
        /// <exception cref="InvalidOperationException">Failed to buy {item.Name}. ({reason})</exception>
        public async Task<IndexedInventoryItem> BuyFromPontyAsync(TradeItem item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));

            var source = new TaskCompletionSource<Expectation<IndexedInventoryItem>>();
            var existingCount = Character.Inventory.CountOf(item.Name);
            var existingItems = Character.Inventory.AsIndexed();

            await using var gameResponseCallback = Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, data =>
            {
                var result = false;

                if (data.ResponseType == GameResponseType.BuyCost)
                    result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. (not enough gold)");

                return Task.FromResult(result);
            });

            await using var gameLogCallback = Socket.On<string>(ALSocketMessageType.GameLog, data =>
            {
                var result = false;

                if (data.EqualsI("item gone"))
                    result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. (item gone)");

                return Task.FromResult(result);
            });

            await using var disappearingTextCallback = Socket.On<DisappearingTextData>(
                ALSocketMessageType.DisappearingText, data =>
                {
                    var result = false;

                    if (data.Message.EqualsI("no space"))
                        result = source.TrySetResult($"Failed to buy {item.Name} from Ponty. (no space)");

                    return Task.FromResult(result);
                });

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character, data =>
            {
                var result = false;
                var newCount = data.Inventory.CountOf(item.Name);

                if (newCount - existingCount == item.Quantity)
                    result = source.TrySetResult(data.Inventory.AsIndexed().Except(existingItems).First());

                return Task.FromResult(result);
            });

            await Socket.Emit(ALSocketEmitType.SecondHandsBuy, new { rid = item.Id });

            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously pings the server.
        /// </summary>
        /// <param name="pingCount">The current ping count.</param>
        /// <returns>
        ///     <see cref="PingAckData" /> <br />
        ///     The ping acknowledgement from the server.
        /// </returns>
        public async Task<PingAckData> PingAsync(long pingCount)
        {
            var source = new TaskCompletionSource<Expectation<PingAckData>>();

            await using var pingAckCallback = Socket.On<PingAckData>(ALSocketMessageType.PingAck,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Ping, new { id = pingCount.ToString() });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously requests your character's data from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="CharacterData" /> <br />
        ///     The character's data.
        /// </returns>
        public async Task<CharacterData> RequestCharacterAsync()
        {
            var source = new TaskCompletionSource<Expectation<CharacterData>>();

            await using var characterCallback = Socket.On<CharacterData>(ALSocketMessageType.Character,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.Property, new { typing = true });
            return await source.Task.WithNetworkTimeout();
        }

        /// <summary>
        ///     Asynchronously requests a full entity refresh from the server.
        /// </summary>
        /// <returns>
        ///     <see cref="EntitiesData" /> <br />
        ///     A full refresh of entity data.
        /// </returns>
        public async Task<EntitiesData> RequestEntitiesAsync()
        {
            var source = new TaskCompletionSource<Expectation<EntitiesData>>();

            await using var entitiesCallback = Socket.On<EntitiesData>(ALSocketMessageType.Entities,
                data => Task.FromResult(source.TrySetResult(data)));

            await Socket.Emit(ALSocketEmitType.SendUpdates, new object());
            return await source.Task.WithNetworkTimeout();
        }

        #endregion

        #region Events

        protected void AttachListeners()
        {
            if (Socket == null)
                throw new NullReferenceException(nameof(Socket));

            Socket.On<StartData>(ALSocketMessageType.Start, OnStartAsync);
            Socket.On<CharacterData>(ALSocketMessageType.Character, OnCharacterAsync);
            Socket.On<GameResponseData>(ALSocketMessageType.GameResponse, OnGameResponseAsync);
            Socket.On<EntitiesData>(ALSocketMessageType.Entities, OnEntitiesAsync);
            Socket.On<AchievementProgressData>(ALSocketMessageType.AchievementProgress, OnAchievementProgressAsync);
            Socket.On<DropData>(ALSocketMessageType.Drop, OnDropAsync);
            Socket.On<EvalData>(ALSocketMessageType.Eval, OnEvalAsync);
            Socket.On<GameErrorData>(ALSocketMessageType.GameError, OnGameErrorAsync);
            Socket.On<PartyUpdateData>(ALSocketMessageType.PartyUpdate, OnPartyUpdateAsync);
            Socket.On<QueuedActionData>(ALSocketMessageType.QueuedActionData, OnQueuedActionAsync);
            Socket.On<QueuedActionResultData>(ALSocketMessageType.QueuedActionResult, OnQueuedActionResult);
            Socket.On<WelcomeData>(ALSocketMessageType.Welcome, OnWelcomeAsync);
            Socket.On<ActionData>(ALSocketMessageType.Action, OnActionAsync);
            Socket.On<DeathData>(ALSocketMessageType.Death, OnDeathAsync);
            Socket.On<DisappearData>(ALSocketMessageType.Disappear, OnDisappearAsync);
            Socket.On<HitData>(ALSocketMessageType.Hit, OnHitAsync);
            Socket.On<NewMapData>(ALSocketMessageType.NewMap, OnNewMapAsync);
            Socket.On<EventAndBossData>(ALSocketMessageType.ServerInfo, OnServerInfo);
        }

        protected async Task<bool> OnAchievementProgressAsync(AchievementProgressData data)
        {
            await AchievementProgress.AddOrUpdateAsync(data.Name, data);
            return false;
        }

        protected async Task<bool> OnActionAsync(ActionData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId))
                await Projectiles.AddOrUpdateAsync(data.ProjectileId, data);

            return false;
        }

        protected async Task<bool> OnCharacterAsync(CharacterData data)
        {
            Character = data;

            //keep a copy of the bank data
            if (data.Bank != null)
                Bank = data.Bank;

            if (data.ExtraEvents.Count > 0)
                foreach (var jArr in data.ExtraEvents)
                {
                    var raw = jArr.ToString();
                    await Socket!.HandleEventAsync(raw);
                }

            return false;
        }

        protected async Task<bool> OnDeathAsync(DeathData data)
        {
            await DestroyEntity(data.Id);
            return false;
        }

        protected async Task<bool> OnDisappearAsync(DisappearData data)
        {
            await DestroyEntity(data.Id);
            return false;
        }

        protected async Task<bool> OnDropAsync(DropData data)
        {
            await Chests.AddOrUpdateAsync(data.Id, data);
            return false;
        }

        protected async Task<bool> OnEntitiesAsync(EntitiesData data)
        {
            await UpdateMonsters(data.Monsters, data.UpdateType == EntitiesUpdateType.All);
            await UpdatePlayers(data.Players, data.UpdateType == EntitiesUpdateType.All);

            return false;
        }

        //TODO: figure out how to handle eval
        protected Task<bool> OnEvalAsync(EvalData data) => Task.FromResult(false);

        protected Task<bool> OnGameErrorAsync(GameErrorData data)
        {
            Warn($"GAME ERROR: {data.Message}");
            return Task.FromResult(false);
        }

        protected async Task<bool> OnGameResponseAsync(GameResponseData data)
        {
            if (!data.ContainsData)
                return false;

            // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
            switch (data.ResponseType)
            {
                case GameResponseType.Cooldown:
                {
                    await Cooldowns.AddOrUpdateAsync(data.SkillName!, new CooldownInfo(data.CooldownMS));
                    break;
                }
                case GameResponseType.ConditionExpired:
                {
                    if (EnumHelper.TryParse(data.Name, out Condition conditionName))
                        await Character!.Conditions.RemoveAsync(conditionName);

                    break;
                }

                case GameResponseType.SkillSuccess:
                {
                    var skillData = GameData.Skills[data.Name!];
                    var cooldownMS = 0;

                    if ((skillData != null) && (skillData.CooldownMS != 0))
                        cooldownMS = skillData.CooldownMS;

                    await Cooldowns.AddOrUpdateAsync(data.Name!, new CooldownInfo(cooldownMS));
                    break;
                }
            }

            return false;
        }

        protected async Task<bool> OnHitAsync(HitData data)
        {
            if (!string.IsNullOrEmpty(data.ProjectileId)
                && await Projectiles.TryGetValueAsync(data.ProjectileId, out var projectileTask))
            {
                var projectile = await projectileTask;
                await Projectiles.RemoveAsync(data.ProjectileId);

                if ((data.Reflect != 0) && !string.IsNullOrEmpty(projectile?.ProjectileId))
                {
                    var newProjectile = projectile with
                    {
                        Damage = data.Reflect, Target = data.HitId, X = Character!.X, Y = Character.Y
                    };

                    await Projectiles.AddOrUpdateAsync(newProjectile.ProjectileId, newProjectile);
                }
            }

            if (data.Kill)
                await DestroyEntity(data.Id);
            else if (data.Damage != 0)
            {
                var entity = await GetEntity(data.Id);

                if (entity != null)
                    entity.Mutate(new Mutation(ALAttribute.Hp, -data.Damage));
            }

            if (data.Reflect != 0)
            {
                var sourceEntity = await GetEntity(data.Source);

                if (sourceEntity != null)
                    sourceEntity.Mutate(new Mutation(ALAttribute.Hp, -data.Reflect));
            }

            return false;
        }

        protected async Task<bool> OnNewMapAsync(NewMapData data)
        {
            await Projectiles.ClearAsync();
            Character!.Mutate(data);

            await OnEntitiesAsync(data.Entities);

            return false;
        }

        protected Task<bool> OnPartyUpdateAsync(PartyUpdateData data)
        {
            Party = data;
            return Task.FromResult(false);
        }

        protected Task<bool> OnQueuedActionAsync(QueuedActionData data)
        {
            if (data.QueuedActionInfo != null)
                Character!.Mutate(data.QueuedActionInfo);

            return Task.FromResult(false);
        }

        protected Task<bool> OnServerInfo(EventAndBossData data)
        {
            var bossInfoDic = (Dictionary<string, BossInfo>) data.BossInfo;
            EventsAndBosses = data;

            foreach ((var name, var bossInfo) in bossInfoDic)
                if (bossInfo.HP == 0)
                {
                    var mData = GameData.Monsters[name];

                    if (mData == null)
                        continue;

                    bossInfo.Mutate(new Mutation(ALAttribute.Hp, mData.HP));
                }

            return Task.FromResult(false);
        }

        protected async Task<bool> OnStartAsync(StartData data)
        {
            Character = data;
            BaseGold = data.BaseGold;
            EventsAndBosses = data.EventAndBossInfo;

            await OnEntitiesAsync(data.Entities);
            await OnCharacterAsync(data);

            return false;
        }

        protected Task<bool> OnQueuedActionResult(QueuedActionResultData data)
        {
            if (Character.QueuedActions != null)
                // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                switch (data.QueuedActionType)
                {
                    case QueuedActionType.Compound:
                        Character.Mutate(Character.QueuedActions with { Compound = null });
                        break;
                    case QueuedActionType.Upgrade:
                        Character.Mutate(Character.QueuedActions with { Upgrade = null });
                        break;
                    case QueuedActionType.Exchange:
                        Character.Mutate(Character.QueuedActions with { Exchange = null });
                        break;
                    default:
                        throw new ArgumentOutOfRangeException($"Unknown upgrade type {(int) data.QueuedActionType}.");
                }

            return Task.FromResult(false);
        }

        protected async Task<bool> OnWelcomeAsync(WelcomeData data)
        {
            if ((Server!.Identifier != data.Identifier) || (Server.Region != data.Region))
                throw new Exception(
                    $"Logged into wrong server. Expected: {Server.Region} {Server.Identifier}  Current: {data.Region} {data.Identifier}");

            await Socket!.Emit(ALSocketEmitType.Loaded, new
            {
                height = 1080,
                width = 1920,
                scale = 2,
                success = 1
            });

            return false;
        }

        #endregion

        #region Helpers

        protected async ValueTask<bool> DestroyEntity(string id)
        {
            var result = await Monsters.RemoveAsync(id) || await Players.RemoveAsync(id);

            var bossInfoDic = (Dictionary<string, BossInfo>) EventsAndBosses.BossInfo;
            bossInfoDic.Remove(id);

            return result;
        }

        protected async ValueTask<EntityBase?> GetEntity(string id) =>
            await Players.TryGetValueAsync(id, out var playerTask)   ? await playerTask :
            await Monsters.TryGetValueAsync(id, out var monsterTask) ? await monsterTask : null;

        protected ValueTask UpdateMonsters(IEnumerable<Monster> monsters, bool full = false)
        {
            if (full)
                return Monsters.AssertAsync(dic =>
                {
                    dic.Clear();

                    foreach (var monster in monsters)
                        dic.Add(monster.Id, monster);
                });

            return Monsters.AssertAsync(dic =>
            {
                foreach (var monster in monsters)
                    if (dic.TryGetValue(monster.Id, out var monsterX))
                        monsterX.Mutate(monster);
            });
        }

        protected ValueTask UpdatePlayers(IEnumerable<Player> players, bool full = false)
        {
            if (full)
                return Players.AssertAsync(dic =>
                {
                    dic.Clear();

                    foreach (var player in players)
                        dic.Add(player.Id, player);
                });

            return Players.AssertAsync(dic =>
            {
                foreach (var player in players)
                {
                    if (Character == player)
                        Character.Mutate(player);

                    if (dic.TryGetValue(player.Id, out var playerX))
                        playerX.Mutate(player);
                }
            });
        }

        #endregion
    }
}